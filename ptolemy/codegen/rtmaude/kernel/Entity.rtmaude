/***termBlock***/
#model('$actorSymbol(model))/**/

/***fireBlock($attr_terms)***/
< '$info(name) : $info(class) |
$attr_terms
>/**/

/***attr_Entity***/
store : emptyMap,
status : enabled,
ports : ($indent(
  $info(ports) 
)),
parameters : ($indent( 
  $info(parameters)
))/**/

/***semantics_Entity***/
(tomod ACTOR is 
  pr ACTOR-BASE .
  pr CASTING-DEF .
  pr PORT-PARAMETERS .
  pr MULTI-PORTS .
  pr PTOLEMY-STRICTNESS .

  class Actor | ports : Configuration,          *** a bunch of ports
        parameters : AssignMap,		*** ptolemy parameters
        status : ActorStatus,		
        store : Memory .		*** local memory

  vars PORTS PORTS' : Configuration .  vars O O' : Oid .  
  var REST : ObjectConfiguration .
  vars V V' : Value .  var VM VM' : ValueMap .  var VAL : AssignMap . 
  var MEM MEM' : Memory . var VI : VarId . var MI : MemoryId .
  vars E : Exp .  var EVTS : Events . 
  vars PI PI' : PortId . var EPIS : EPortIdSet .
  var PS : PortStatus .  var DPS : DetPortStatus .
  var CHS : ChannelSet .
  var UPDATED : Bool .
  var K : K .  var VIL : VarIdList . var VL : ValueList .

---------------------------------------------------------------------
--- Message
---------------------------------------------------------------------

  --- add events to ports 
  --- active-evt events are generated at each step of computation,
  --- and it is dilivered to each port
  eq active-evt(event(O ! PI, V))
    < O : Actor | 
    status : enabled,
    ports : < PI : Port | status : PS, value : V' > PORTS 
    > 
  = < O : Actor | 
    ports : < PI : Port | status : present, value : V > PORTS 
     > .

---------------------------------------------------------------------
--- Semantics Steps
---------------------------------------------------------------------

  eq init(Actor, OBJ:Object) = OBJ:Object .

  --- in each new ports we must "reset" all ports to 'unknown'. 
  eq prefire(Actor, < O : Actor | ports : PORTS >) 
   = < O : Actor | ports : clearPorts(PORTS) > .

  --- During fixpoint computation, variables and ports of an actor
  --- is computed.

 **** variable ****

  --- when variable is already computed, the value is used.
  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
        store : MI |->  k(VI -> K) ; VI |-> V ; MEM
    > REST)
   = portFixPoints(true,
    < O : Actor | 
        store : MI |-> k(V -> K) ; VI |-> V ; MEM
    > REST) .

  --- if the variable is not yet computed, it will computed
  ceq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    parameters : VI |-> E ; VAL,
    store : MI |-> k(VI -> K) ; MEM
    > REST)
   = portFixPoints(true,
    < O : Actor | 
    store : VI |-> k(E) ; MI |-> k(VI -> K) ; MEM
    > REST) 
  if not VI in MEM .

 **** port variable ****

  --- isPresent is a special type of expression, which denotes
  --- whether given port (of current actor) is present or not

  ops isPresent : PortId -> ProperExp [ctor] .

  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    ports : < PI : Port | status : DPS > PORTS,
    store : MI |-> k(isPresent(PI) -> K) ; MEM
    > REST)
   = portFixPoints(true,
    < O : Actor | 
    store : MI |-> k(# (DPS == present) -> K) ; MEM
    > REST) .

 **** closure(function) ****

  op restore : ValueMap -> KLabel .

  --- function will be computed with new variable environment
  --- defined by function arguments.
  ---FIXME: free variable in E should be computed first?!
  ---    Since a clousre can be dilivered to other actors, the problem is 
  ---    much more complicated
  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    store : MI |-> k((function(VIL) E)(VL) -> K) ; MEM
    > REST)
   = portFixPoints(true,
    < O : Actor | 
    store : MI |-> k(E -> restore(MEM) -> K) ; (VIL |-> VL) <+ MEM
    > REST) .

  --- after computing a function, environments should be restored.
  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    store : MI |-> k(restore(VM') -> K) ; MEM
    > REST)
   = portFixPoints(true,
    < O : Actor | 
    store : MI |-> k(K) ; VM' <+ MEM
    > REST) .

 **** port ****

  --- deliver a value of ports to connected ports with the status 'unknown'
  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    ports :  < PI : OutPort | status : DPS, value : V > PORTS 
    >
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    status : enabled,
    ports : < PI' : InPort | status : unknown > PORTS' 
    > 
    REST)
   = portFixPoints(true, 
    < O : Actor | > 
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    ports : < PI' : InPort | status : DPS, value : V > PORTS' 
    > 
    REST) .

 **** multi port ****

  ceq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    ports :  < PI : OutPort | > PORTS 
    >
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    status : enabled,
    ports : 
        < PI' : MultiInPort | 
        channels : CHS
        > PORTS'
    > 
    REST)
   = portFixPoints(true, 
    < O : Actor | > 
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    ports : 
        < PI' : MultiInPort | 
        channels : ([O ! PI,unknown,# 0] ; CHS)
        > PORTS'
    > 
    REST)  
   if not (O ! PI) in CHS .

  eq portFixPoints(UPDATED,
    < O : Actor | 
    status : enabled,
    ports :  < PI : OutPort | status : DPS, value : V > PORTS 
    >
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    status : enabled,
    ports : 
        < PI' : MultiInPort | 
        channels : ([O ! PI,unknown,V'] ; CHS)
        > PORTS'
    > 
    REST)
   = portFixPoints(true, 
    < O : Actor | > 
    ((O ! PI) ==> ((O' ! PI') ; EPIS)) 
    < O' : Actor | 
    ports : 
        < PI' : MultiInPort | 
        channels : ([O ! PI,DPS,V] ; CHS)
        > PORTS'
    > 
    REST) .

  --- update port-variables 
  --- clear store as well (to save a state space)
  eq postfire(Actor, 
    < O : Actor | 
    status : enabled,
    ports : PORTS, 
    parameters : VAL, 
    store : MEM 
    >)
  = < O : Actor | 
    parameters : updateParam(VAL, PORTS), 
    store : emptyMap
    > .

  eq postfire(Actor, < O : Actor | status : disabled >)
   = < O : Actor | > .
endtom)
/**/

/***formal_Entity***/
(tomod CHECK-ACTOR is
  inc MODELCHECK-BASE .
  pr ACTOR .

  op |_ : VarCheckSet -> ActorPattern [ctor] .
  
  sort VarCheck VarCheckSet .
  subsort VarCheck < VarCheckSet .
  op _=_ : VarId Exp -> VarCheck [ctor prec 71] .
  op `(`) : -> VarCheckSet .
  op _`,_ : VarCheckSet VarCheckSet -> VarCheckSet [ctor assoc comm id: () prec 121] .

  var CF : Configuration .  var O : Oid .  var VI : VarId . 
  var E E' : Exp .  var VM : ValueMap . var VS : VarCheckSet .

  ceq {< O : Actor | parameters : (VI |-> E) ; VM > CF} |= O | (VI = E', VS)
   = {< O : Actor | parameters : VM > CF} |= O | VS
   if E equals E' == #(true) .
  eq {< O : Actor | parameters : VM > CF} |= O | () = true .
  eq {< O : Actor | parameters : VM > CF} |= O | VS = false [owise] .
endtom)
/**/