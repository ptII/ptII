/***attr_FSMActor***/
currState : '$info(initState),
initState : '$info(initState),
transitions : ($indent( $info(transitions) ))/**/

/***semantics_FSMActor***/
(tomod FSM-ACTOR is 
  inc ACTOR .
  pr PORTS .

  class FSM-Actor | currState : Location, 
                    initState : Location,
                    transitions : TransitionSet .
    subclass FSM-Actor < Actor .
  eq ^ FSM-Actor = Actor .

  --- Location is a name of a state
  sort Location .
  subsorts Qid < Location .

  sort TransitionId .
  subsort Qid < TransitionId .
  
  sort Transition TransitionSet .
  subsort Transition < TransitionSet .
  op _:_-->_`{_`} : TransitionId Location Location TransBody -> Transition [ctor] .
  op emptyTransitionSet : -> TransitionSet [ctor] .
  op _;_ : TransitionSet TransitionSet -> TransitionSet
                               [ctor assoc comm id: emptyTransitionSet] .

  --- The transition body has guard, output, and set.
  sort TransBody .
  op guard:_output:_set:_ : Exp AssignMap AssignMap -> TransBody [ctor] .

----------------------

  vars CF PORTS PORTS' : Configuration .  vars O O' QUE : Oid .
  vars REST : ObjectConfiguration .
  vars PI PI' : PortId .  var PS : PortStatus .
  vars L STATE STATE' STATE'' : Location . var TI : TransitionId .
  var VM : ValueMap .  var AM OL AL VAL : AssignMap .
  var MEM MEM' : Memory . var CP : Computation .
  var VA : ValueAssignment .  var BODY : TransBody .
  var VI : VarId . vars V : Value .  var VM : ValueMap .
  var TRANSSET : TransitionSet .  vars E TG : Exp .

---------------------------------------------------------------------
--- Semantics Steps
---------------------------------------------------------------------

  --- set to calculate the guards of transitions from the current state
  eq prefire(FSM-Actor, 
    < O : FSM-Actor | 
      store : MEM,
      currState : STATE,
      transitions : TRANSSET
    >)
   = prefire(^ FSM-Actor, 
    < O : FSM-Actor | 
      store : evalGuards(STATE, TRANSSET) ; MEM
    >) .

  op @guard : TransitionId -> MemoryId . 
  op evalGuards : Location TransitionSet -> Memory .

  eq evalGuards(STATE, 
        (TI : STATE --> STATE' {guard: TG output: OL set: AL}) ; TRANSSET)
   = @guard(TI) |-> k(TG) ; evalGuards(STATE, TRANSSET) .
  eq evalGuards(STATE, TRANSSET) = emptyMap [owise] .

--- During fix-computation of FSM-actor, several informations,
--- such as guard and next state, will be stored to the memory
--- Such information will be written to the actor during executeStep

  op @next : Location -> MemoryItem .        --- next state
  op @out : PortId -> MemoryId .            --- output(port) result
  op @set : VarId -> MemoryId .            --- set(variable) result

  --- Take and compute a transition whose guard condition is true
  ---FIXME: Order conflict
  ---        Down & Up of CompositeActor should be computed first
  ---FIXME: only one transition should be possible
  eq portFixPoints(
    < O : FSM-Actor | 
      status : enabled,
      ports : < PI : InPort | status : present > PORTS,       
      store : @guard(TI) |-> # true ; MEM,
      transitions : (
        (TI : STATE --> STATE' {guard: TG output: OL set: AL}) ; TRANSSET)
    > REST) 
  =  portFixPoints(
    < O : FSM-Actor |
      ports : < PI : InPort | > PORTS,
      store : @next(STATE') ; evalOut(OL) ; evalSet(AL) ; clearGuards(MEM)
    > REST) .
    
  --- if no transition is applicable, set every outport absent.
  ceq portFixPoints(
    < O : FSM-Actor |
      status : enabled,
      ports : < PI : InPort | status : present > PORTS,      
      store : @guard(TI) |-> # false ; MEM
    > REST)
  =  portFixPoints(
    < O : FSM-Actor |
      ports : < PI : InPort | > setUnknownOutPortsAbsent(PORTS),      
      store : clearGuards(MEM)
    > REST)
   if allGuardsFalse(MEM) .
   
  --- if every input port is absent, set every output absent as well.
  ceq portFixPoints(
    < O : FSM-Actor |
      status : enabled,
      ports : < PI : InPort | status : absent > 
              < PI : OutPort | status : unknown > PORTS
    > REST)
  =  portFixPoints(
    < O : FSM-Actor |
      ports : < PI : InPort | > 
              < PI : OutPort | status : absent > 
              setUnknownOutPortsAbsent(PORTS)    
    > REST)
   if allInputPortsAbsent(PORTS) .
   
  op setUnknownOutPortsAbsent : Configuration -> Configuration .
  eq setUnknownOutPortsAbsent(< PI : OutPort | status : unknown > PORTS)
   = < PI : OutPort | status : absent > setUnknownOutPortsAbsent(PORTS) .
  eq setUnknownOutPortsAbsent(PORTS) = PORTS [owise] .
  
  op allInputPortsAbsent : Configuration -> Bool .
  eq allInputPortsAbsent(< PI : OutPort | status : absent > PORTS) = true .
  eq allInputPortsAbsent(PORTS) = false [owise] .
  
  op allGuardsFalse : Memory -> Bool .
  ceq allGuardsFalse(@guard(TI) |-> KR:KResult ; MEM) = false
   if KR:KResult =/= # false .
  eq allGuardsFalse(MEM) = true [owise] .

  op clearGuards : Memory -> Memory .
  eq clearGuards(@guard(TI) |-> KR:KResult ; MEM) = clearGuards(MEM) .
  eq clearGuards(MEM) = MEM [owise] .

  op evalOut : AssignMap -> Memory .
  eq evalOut((VI |-> E) ; AM) = @out(VI) |-> k(E) ; evalOut(AM) .
  eq evalOut(emptyMap) = emptyMap .

  op evalSet : AssignMap -> Memory .
  eq evalSet((VI |-> E) ; AM) = @set(VI) |-> k(E) ; evalOut(AM) .
  eq evalSet(emptyMap) = emptyMap .

  --- write output result of transition to ports
  eq portFixPoints(
    < O : FSM-Actor | 
      ports : 
        < PI' : InPort | status : present >  
        < PI : OutPort | > PORTS,
      store : @out(PI) |-> V ; MEM 
    >
    REST)
   = portFixPoints(
    < O : FSM-Actor | 
      ports : 
        < PI' : InPort | > 
        < PI : OutPort | status : present, value : V >
        if noOutValue(MEM) then setUnknownOutPortsAbsent(PORTS) else PORTS fi,
      store : MEM 
    >
    REST) .
    
  --- if there is no output action, but a transition taken.
  ceq portFixPoints(
    < O : FSM-Actor |
      ports : < PI' : InPort | status : present >
              < PI : OutPort | status : unknown >
      		 PORTS,
      store : @next(STATE') ; MEM
    >
    REST)
   = portFixPoints(
    < O : FSM-Actor |
      ports : < PI' : InPort | >
              < PI : OutPort | status : absent >
              setUnknownOutPortsAbsent(PORTS),
      store : @next(STATE') ; MEM
    >
    REST) 
   if noOutValue(MEM) .
    
  op noOutValue : Memory -> Bool .
  eq noOutValue(@out(PI) |-> V ; MEM) = false .
  eq noOutValue(MEM) = true [owise] .

  *** FSM-Actor does NOT generate events in our first version, only changes
  *** the internal state/valuation as a result of applying one transition ...

  --- computation result of states and variables is written
  eq postfire(FSM-Actor,
    < O : FSM-Actor | 
      status : enabled,
      ports : < PI' : InPort | status : present > PORTS, 
      parameters : VAL, 
      currState : STATE,
      store : MEM
    >)
  =  postfire(^ FSM-Actor,
    < O : FSM-Actor | 
      parameters : updateVars(VAL, MEM), 
      currState : updateState(STATE, MEM)
    >) .
    
  op updateVars : AssignMap Memory -> AssignMap .
  eq updateVars((VI |-> E) ; AM, (@set(VI) |-> V) ; MEM)
   = (VI |-> V) ; updateVars(AM, MEM) .
  eq updateVars(AM, MEM) = AM [owise] .

  op updateState : Location Memory -> Location .
  eq updateState(STATE, @next(STATE') ; MEM) = STATE' .
  eq updateState(STATE, MEM) = STATE [owise] .
endtom)
/**/

/***formal_FSMActor***/
(tomod CHECK-FSM-ACTOR is
  pr FSM-ACTOR .
  pr CHECK-ACTOR .

  var CF : Configuration .  var O : Oid .   var L : Location . 

  op @_ : Location -> ActorPattern [ctor] .
  eq {< O : FSM-Actor | currState : L > CF} |= O @ L = true .
endtom)
/**/