/***moduleName***/
FSM-ACTOR/**/

/***className***/
FSM-Actor/**/

/***checkModuleName***/
CHECK-FSM-ACTOR/**/

/***attr_FSMActor***/
currState : '$info(initState),
initState : '$info(initState),
transitions : ($indent( $info(transitions) ))/**/

/***sharedBlock***/
(tomod FSM-ACTOR is 
  inc ACTOR .
  pr PORTS .

  class FSM-Actor | currState : Location, 
                    initState : Location,
                    transitions : TransitionSet .
    subclass FSM-Actor < Actor .
  eq ^ FSM-Actor = Actor .

  --- Location is a name of a state
  sort Location .
  subsorts Qid < Location .

  sort TransitionId .
  subsort Qid < TransitionId .
  
  sort Transition TransitionSet .
  subsort Transition < TransitionSet .
  op _:_-->_`{_`} : TransitionId Location Location TransBody -> Transition [ctor] .
  op emptyTransitionSet : -> TransitionSet [ctor] .
  op _;_ : TransitionSet TransitionSet -> TransitionSet
                               [ctor assoc comm id: emptyTransitionSet] .

  --- The transition body has guard, output, and set.
  sort TransBody .
  op guard:_output:_set:_ : Exp AssignMap AssignMap -> TransBody [ctor] .

----------------------

  vars CF PORTS : Configuration .  vars O O' QUE : Oid .
  vars REST : ObjectConfiguration .
  vars PI PI' : PortId .  var PS : PortStatus .
  vars L STATE STATE' STATE'' : Location . var TI : TransitionId .
  var VM : ValueMap .  var AM OL AL VAL : AssignMap .
  var MEM : Memory . var CP : Computation .
  var VA : ValueAssignment .  var BODY : TransBody .
  var VI : VarId . vars V : Value .  var VM : ValueMap .
  var TRANSSET : TransitionSet .  vars E TG : Exp .
  var UPDATED : Bool .

---------------------------------------------------------------------
--- Semantics Steps
---------------------------------------------------------------------

  --- set to calculate the guards of transitions from the current state
  eq prefire(FSM-Actor, 
    < O : FSM-Actor | 
      store : MEM,
      currState : STATE,
      transitions : TRANSSET
    >)
   = prefire(^ FSM-Actor, 
    < O : FSM-Actor | 
      store : evalGuards(STATE, TRANSSET) ; MEM
    >) .

  op @guard : TransitionId -> MemoryId . 
  op evalGuards : Location TransitionSet -> Memory .

  eq evalGuards(STATE, 
        (TI : STATE --> STATE' {guard: TG output: OL set: AL}) ; TRANSSET)
   = @guard(TI) |-> k(TG) ; evalGuards(STATE, TRANSSET) .
  eq evalGuards(STATE, emptyTransitionSet) = emptyMap .

--- During fix-computation of FSM-actor, several informations,
--- such as guard and next state, will be stored to the memory
--- Such information will be written to the actor during executeStep

  op @next : Location -> MemoryItem .        --- next state
  op @out : PortId -> MemoryId .            --- output(port) result
  op @set : VarId -> MemoryId .            --- set(variable) result

  --- Take and compute a transition whose guard condition is true
  ---FIXME: Order conflict
  ---        Down & Up of CompositeActor should be computed first
  ---FIXME: only one transition should be possible
  ---FIXME: if every guard expression is not reduced to value,
  ---       it is ERROR and should be treated. (zero-time Delay)
  eq portFixPoints(UPDATED,
    < O : FSM-Actor | 
      status : enabled,
      ports : < PI : InPort | status : present > PORTS,       
      store : @guard(TI) |-> # true ; MEM,
      transitions : (
        (TI : STATE --> STATE' {guard: TG output: OL set: AL}) ; TRANSSET)
    > REST) 
  =  portFixPoints(true,
    < O : FSM-Actor | 
      store : @next(STATE') ; evalOut(OL) ; evalSet(AL) ; clearGuards(MEM)
    > REST) .

  op clearGuards : Memory -> Memory .
  eq clearGuards(@guard(TI) |-> KR:KResult ; MEM) = clearGuards(MEM) .
  eq clearGuards(MEM) = MEM [owise] .

  op evalOut : AssignMap -> Memory .
  eq evalOut((VI |-> E) ; AM) = @out(VI) |-> k(E) ; evalOut(AM) .
  eq evalOut(emptyMap) = emptyMap .

  op evalSet : AssignMap -> Memory .
  eq evalSet((VI |-> E) ; AM) = @set(VI) |-> k(E) ; evalOut(AM) .
  eq evalSet(emptyMap) = emptyMap .

  --- write output result of transition to ports
  eq portFixPoints(UPDATED,
    < O : FSM-Actor |
      status : enabled,    
      ports : 
        < PI' : InPort | status : present > PORTS,    
      store : @out(PI) |-> V ; MEM
    > REST)
   = portFixPoints(true,
    < O : FSM-Actor |
      ports : 
        < PI' : InPort | > updateOutPorts(PORTS, @out(PI) |-> V ; MEM),
      store : clearOutputs(MEM)
    > REST) .

  op updateOutPorts : Configuration Memory -> Configuration .
  eq updateOutPorts(< PI : OutPort | > PORTS, @out(PI) |-> V ; MEM)
   = < PI : OutPort | status : present, value : V >  ---NOTE: overwritten 
     updateOutPorts(PORTS, MEM) .
  eq updateOutPorts(PORTS, MEM) = PORTS [owise] .    --- others should be absent

  op clearOutputs : Memory -> Memory .
  eq clearOutputs(@out(PI) |-> V ; MEM) = clearOutputs(MEM) .
  eq clearOutputs(MEM) = MEM [owise] .

  *** FSM-Actor does NOT generate events in our first version, only changes
  *** the internal state/valuation as a result of applying one transition ...

  --- computation result of states and variables is written
  eq postfire(FSM-Actor,
    < O : FSM-Actor | 
      status : enabled,
      ports : < PI' : InPort | status : present > PORTS, 
      parameters : VAL, 
      currState : STATE,
      store : MEM
    >)
  =  postfire(^ FSM-Actor,
    < O : FSM-Actor | 
      parameters : updateVars(VAL, MEM), 
      currState : updateState(STATE, MEM)
    >) .
    
  op updateVars : AssignMap Memory -> AssignMap .
  eq updateVars((VI |-> E) ; AM, (@set(VI) |-> V) ; MEM)
   = (VI |-> V) ; updateVars(AM, MEM) .
  eq updateVars(AM, MEM) = AM [owise] .

  op updateState : Location Memory -> Location .
  eq updateState(STATE, @next(STATE') ; MEM) = STATE' .
  eq updateState(STATE, MEM) = STATE [owise] .
endtom)

(tomod CHECK-FSM-ACTOR is
  pr CHECK-COMPOSITE-ACTOR .
  pr FSM-ACTOR .

  var CF : Configuration .  var O : Oid .   var L : Location . 

  op @_ : Location -> ActorPattern [ctor] .
  eq {< O : FSM-Actor | currState : L > CF} |= O @ L = true .
endtom)
/**/