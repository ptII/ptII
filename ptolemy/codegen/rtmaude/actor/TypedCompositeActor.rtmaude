/***moduleName***/
COMPOSITE-ACTOR/**/

/***checkModuleName***/
CHECK-COMPOSITE-ACTOR/**/

/***className***/
CompositeActor/**/

/***attr_CompositeActor***/
innerActors : ($indent( 
  $info(actors)
$info(connections)
))
/**/

/***sharedBlock***/
(tomod COMPOSITE-ACTOR is 
  inc ACTOR .
  class CompositeActor | innerActors : Configuration .
    subclass CompositeActor < Actor .
  eq ^ CompositeActor = Actor .

  vars CF PORTS PORTS' : Configuration .
  vars PI PI' : PortId . var EPIS : EPortIdSet . 
  var PS : PortStatus . var DPS : DetPortStatus .
  vars REST ACTS : ObjectConfiguration . var OBJ : Object . vars QUE O O' : Oid .
  var V : Value .  vars VM VAL : ValueMap .  var E : Exp .
  var MEM MEM' : Memory .  var K : K .
  var VIL : VarIdList . var VL : ValueList .
  vars EQ EQ1 EQ2 EQ3 : EventQueue .  var EVTS EVTS' : Events . var T : Time .
  var AI : ActorID . var VI : VarId . var MI : MemoryId .
  var UPDATED UPDATED' : Bool .

---------------------------------------------------------------------
--- Message & Time
---------------------------------------------------------------------

--- Pass events to different level
--- An event dilivery (to event-queue or to ports) is accomplished
--- by related event message. In here, dilivering events to
--- different level is defined

  --- evt message (to top)
  eq < O : CompositeActor | 
       innerActors : CF evt(event(AI ! PI, V), T) 
     >
   = < O : CompositeActor | 
       innerActors : CF 
     >
     evt(event((O . AI) ! PI, V), T)  .

  --- active-evt message (from top)
  eq active-evt(event((O . AI) ! PI, V))
     < O : CompositeActor | 
       status : enabled,
       innerActors : CF 
     >
   = < O : CompositeActor | 
       innerActors : active-evt(event(AI ! PI, V)) CF 
     > .
     
  eq delta(< O : CompositeActor | innerActors : CF >, T)
   = < O : CompositeActor | innerActors : delta(CF, T) > .

---------------------------------------------------------------------
--- Semantics Steps
---------------------------------------------------------------------
  
  eq init(CompositeActor,
        < O : CompositeActor | innerActors : CF >)
   = init(^ CompositeActor,
        < O : CompositeActor | innerActors : initAll(CF) >) .

  --- children actors are also initialized for computational step
  eq prefire(CompositeActor, 
    < O : CompositeActor | innerActors : CF >)
   = prefire(^ CompositeActor,
    < O : CompositeActor | innerActors : prefireAll(CF) >) .

  --- In hierarchical model of actors, Fix-point computation of all levels 
  ---  will be executed at the same time.
  --- (Caution: Transparent case. when opaque case, it will be more
  ---  complicate. But we assume that everything is DE, so no problem here)
  --- This over-level fixpoint computation is accomplished by starting
  --- and terminating portFixPoint at the same time for all level.

 **** setting hierarchical model ****

  --- if innerActors do not start portFixPoint, start it.
  eq portFixPoints(UPDATED,
    < O : CompositeActor | 
      status : enabled,
      innerActors : ACTS 
    > 
    REST)
  =  portFixPoints(true,
    < O : CompositeActor | 
      innerActors : portFixPoints(true,ACTS) 
    > 
    REST) .

 **** variable ****

  --- In Ptolemy, scope of variable should contains ancestors' of
  --- current actor. Also, children can share the same variables
  --- of a parent.

  --- variables defined at the parent actor, and its already computed.
  ceq portFixPoints(UPDATED,
    < O : CompositeActor |
      status : enabled, 
      store : VI |-> V ; MEM,
      innerActors : portFixPoints(UPDATED',
        < O' : Actor |
          status : enabled,
          store : MI |-> k(VI -> K) ; MEM'
        >
        ACTS)
    > REST)
   = portFixPoints(true,
    < O : CompositeActor |
      innerActors : portFixPoints(true,
        < O' : Actor |
          store : MI |-> k(V -> K) ; MEM'
        >
        ACTS)
    > REST)
  if not VI in MEM' .

  --- If a variable is not in current actor and not already computed in
  --- the parent actor, it will be computed at the parent
  ceq portFixPoints(UPDATED,
    < O : CompositeActor |
      status : enabled, 
      parameters : VI |-> E ; VAL,
      store : MEM,
      innerActors : portFixPoints(UPDATED',
        < O' : Actor |
          status : enabled,
          store : MI |-> k(VI -> K) ; MEM'
        >
        ACTS)
    > REST)
   = portFixPoints(true,
    < O : CompositeActor |
      store : VI |-> k(E) ; MEM,
      innerActors : portFixPoints(true, < O' : Actor | > ACTS)
    > REST)
  if not VI in MEM' /\ not VI in MEM .

  --- If a variable is not in current actor and not already computed in
  --- the parent actor, and no variable is in parent actor,
  --- it will refer its parent again.
  ceq portFixPoints(UPDATED,
    < O : CompositeActor |
      status : enabled, 
      parameters : VAL,
      store : MEM,
      innerActors : portFixPoints(UPDATED',
        < O' : Actor |
          status : enabled,
          store : MI |-> k(VI -> K) ; MEM'
        >
        ACTS)
    > REST)
   = portFixPoints(true,
    < O : CompositeActor |
      store : VI |-> k(VI) ; MEM,
      innerActors : portFixPoints(true, < O' : Actor | > ACTS)
    > REST)
  if not VI in MEM' /\ not VI in MEM /\ not VI in VAL .

 **** port ****

  --- The value of ports can be dilivered among different levels
  --- if connections exist.

  --- Down (Inner Actor)
  eq portFixPoints(UPDATED,
    < O : CompositeActor |
      status : enabled, 
      ports : < PI : InPort | status : DPS, value : V > PORTS,
      innerActors : portFixPoints(UPDATED',
        < O' : Actor | 
          status : enabled,
          ports : < PI' : InPort | status : unknown > PORTS' 
        >
        ((parent ! PI) ==> ((O' ! PI') ; EPIS)) 
        ACTS)
    > REST)
   = portFixPoints(true,
    < O : CompositeActor |
      innerActors :  portFixPoints(true,
        < O' : Actor | 
          ports : < PI' : InPort | status : DPS, value : V > PORTS' 
        >
        ((parent ! PI) ==> ((O' ! PI') ; EPIS)) 
        ACTS)
    > REST) .

  --- Up (Inner Actor)
  eq portFixPoints(UPDATED,
    < O : CompositeActor |
      status : enabled, 
      ports : < PI : OutPort | status : unknown > PORTS,
      innerActors : portFixPoints(UPDATED',
        < O' : Actor | 
          ports : < PI' : OutPort | status : DPS, value : V > PORTS' 
        >
        ((O' ! PI') ==> ((parent ! PI) ; EPIS)) 
        ACTS)
    > REST)
   = portFixPoints(true,
    < O : CompositeActor |
      ports : < PI : OutPort | status : DPS, value : V > PORTS,
      innerActors : portFixPoints(true,
        < O' : Actor | >
        ((O' ! PI') ==> ((parent ! PI) ; EPIS)) 
        ACTS)
    > REST) .

 **** final condition (redefined) ****

  --- if there a change (from bottom)
  eq portFixPoints(false,
    < O : CompositeActor |
      status : enabled,
      innerActors : portFixPoints(true,ACTS)
    >
    REST
    )
  =  portFixPoints(true, < O : CompositeActor | > REST) .

------------------------

  --- terminate all portFixPoints (from top)
  eq postfire(C:Cid,
    < O : CompositeActor | 
      innerActors : portFixPoints(UPDATED, ACTS)
    >)
  =  postfire(C:Cid,
    < O : CompositeActor | 
      innerActors : ACTS
    >) .

  --- variables of inner actors cannot be accessed from
  --- outside. Hence, updating those before doing parent actor
  --- events sholud be also considered.
  --- NOTE: ACTS is an ObjectConfiguration.
  eq postfire(CompositeActor,
    < O : CompositeActor | 
      status : enabled,
      innerActors : ACTS
    >)
  =  postfire(^ CompositeActor, 
    < O : CompositeActor | 
      innerActors : postfireAll(ACTS) 
    >) .
endtom)

(tomod CHECK-COMPOSITE-ACTOR is
  pr COMPOSITE-ACTOR .
  pr CHECK-ACTOR .

  var CF ACTS : Configuration .  var PO : Oid .  
  var AI AI' : ActorID .  var AP : ActorPattern .

  eq {< PO : CompositeActor | innerActors : ACTS > CF} |= (PO . AI) AP
   = {ACTS} |= AI AP .   --- accessing inner actor,, ?
   
  --- formula convention with an actor scope
  op _:_ : ActorID Formula -> Formula .
  
  vars F1 F2 : Formula .
  
  eq AI : True = True .
  eq AI : False = False .
  eq AI : (~ F1) = ~ (AI : F1) .
  eq AI : (O F1) = O (AI : F1) .
  eq AI : (F1 /\ F2) = (AI : F1) /\ (AI : F2) .
  eq AI : (F1 \/ F2) = (AI : F1) \/ (AI : F2) .
  eq AI : (F1 U F2) = (AI : F1) U (AI : F2) .
  eq AI : (F1 R F2) = (AI : F1) R (AI : F2) .
  
  eq AI : (AI' AP) = (AI . AI') AP .
  
endtom)
/**/


