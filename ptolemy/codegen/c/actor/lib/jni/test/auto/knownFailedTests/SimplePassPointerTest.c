/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2009 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
#ifndef PT_NO_MATH_H
#include <math.h>
#endif
#ifndef PT_NO_STDIO_H
#include <stdio.h>
#endif
#ifndef PT_NO_STRING_H
#include <string.h>
#endif
#ifndef PT_NO_STDLIB_H
#include <stdlib.h>
#endif
#ifndef PT_NO_STDARG_H
#include <stdarg.h>
#endif
/* Generate type resolution code for .SimplePassPointerTest */
// Constants.
#define MISSING 0
typedef unsigned char boolean;
typedef char* string;
/* Infinity is a valid Ptolemy identifier. */
#define Infinity HUGE_VAL
#ifdef linux
/* Linux tends to have NAN. */
#define NaN (__builtin_nanf (""))
#else /*linux*/
#define NaN nanf(0)
#endif /*linux*/
#define false 0
#define true 1
#define TYPE_Token -1
#define TYPE_Double 0
#define TYPE_IntArray 1
#define TYPE_String 2
#define TYPE_Int 3
#define TYPE_Boolean 4
#define TYPE_StringArray 5
#define FUNC_isCloseTo 0
#define FUNC_delete 1
#define FUNC_convert 2
typedef struct token Token;
typedef double DoubleToken;
Token IntArray_new(int size, int given, ...);
struct intarray {
    int size;                                   // size of the array.
    int* elements;                            // array of Token elements.
    char elementType;                                 // type of the elements.
};
typedef struct intarray* IntArrayToken;
typedef char* StringToken;
typedef int IntToken;
typedef boolean BooleanToken;
Token StringArray_new(int size, int given, ...);
struct stringarray {
    int size;                                   // size of the array.
    string* elements;                            // array of Token elements.
    char elementType;                                 // type of the elements.
};
typedef struct stringarray* StringArrayToken;
// Token structure containing the specified types.
struct token {         // Base type for tokens.
    char type;         // TYPE field has to be the first field.
    union typeMembers {
        // type member declarations [i.e. Type1Token Type1;]
        DoubleToken Double;
        IntArrayToken IntArray;
        StringToken String;
        IntToken Int;
        BooleanToken Boolean;
        StringArrayToken StringArray;
    } payload;
};
Token emptyToken; /* Used by *_delete() and others. */
Token Double_new(double d);
// IntArray_get: get an element of an array.
#define IntArray_length(array) ((array).payload.IntArray->size)
int IntArray_get(Token array, int i) {
    // Token result;
    // result.type = array.payload.IntArray->elementType;
    // result.payload.Int = ((int *) array.payload.IntArray->elements)[i];
    // return result;
    return ((int *) array.payload.IntArray->elements)[i];
}
// IntArray_set: set an element of an array.
void IntArray_set(Token array, int i, int element) {
    ((int *) array.payload.IntArray->elements)[i] = element;
}
// IntArray_resize: Change the size of an array,
// preserving those elements that fit.
void IntArray_resize(Token array, int size) {
    array.payload.IntArray->size = size;
    array.payload.IntArray->elements = (int*) realloc(
    array.payload.IntArray->elements, size * sizeof(int));
}
// IntArray_insert: Append the specified element to the end of an array.
void IntArray_insert(Token array, int token) {
    int oldSize = array.payload.IntArray->size++;
    IntArray_resize(array, array.payload.IntArray->size);
    ((int *) array.payload.IntArray->elements)[oldSize] = token;
}
Token String_new(char* s);
Token Int_new(int i);
Token Boolean_new(boolean b);
// StringArray_get: get an element of an array.
#define StringArray_length(array) ((array).payload.StringArray->size)
string StringArray_get(Token array, int i) {
    // Token result;
    // result.type = array.payload.StringArray->elementType;
    // result.payload.String = ((string *) array.payload.StringArray->elements)[i];
    // return result;
    return ((string *) array.payload.StringArray->elements)[i];
}
// StringArray_set: set an element of an array.
void StringArray_set(Token array, int i, string element) {
    ((string *) array.payload.StringArray->elements)[i] = element;
}
// StringArray_resize: Change the size of an array,
// preserving those elements that fit.
void StringArray_resize(Token array, int size) {
    array.payload.StringArray->size = size;
    array.payload.StringArray->elements = (string*) realloc(
    array.payload.StringArray->elements, size * sizeof(string));
}
// StringArray_insert: Append the specified element to the end of an array.
void StringArray_insert(Token array, string token) {
    int oldSize = array.payload.StringArray->size++;
    StringArray_resize(array, array.payload.StringArray->size);
    ((string *) array.payload.StringArray->elements)[oldSize] = token;
}
#define StringtoInt atoi
#define StringtoDouble atof
#define StringtoLong atol
#define DoubletoInt (int)
#define InttoDouble (double)
#define InttoLong (long)
char* InttoString (int i) {
    char* string = (char*) malloc(sizeof(char) * 12);
    sprintf((char*) string, "%d", i);
    return string;
}
char* LongtoString (long long l) {
    char* string = (char*) malloc(sizeof(char) * 22);
    sprintf(string, "%lld", l);
    return string;
}
char* DoubletoString (double d) {
    int index;
    char* string = (char*) malloc(sizeof(char) * 20);
    sprintf(string, "%.14g", d);
    // Make sure that there is a decimal point.
    if (strrchr(string, '.') == NULL) {
        index = strlen(string);
        if (index == 20) {
            string = (char*) realloc(string, sizeof(char) * 22);
        }
        string[index] = '.';
        string[index + 1] = '0';
        string[index + 2] = '\0';
    }
    return string;
}
char* BooleantoString (boolean b) {
    char *results;
    if (b) {
        // AVR does not have strdup
        results = (char*) malloc(sizeof(char) * 5);
        strcpy(results, "true");
    } else {
        results = (char*) malloc(sizeof(char) * 6);
        strcpy(results, "false");
    }
    return results;
}
char* UnsignedBytetoString (unsigned char b) {
    char* string = (char*) malloc(sizeof(char) * 3);
    sprintf(string, "%d", (int) b);
    return string;
}
// functionHeader:
Token Double_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Double_convert (Token thisToken, ...);
// functionHeader:
Token IntArray_isCloseTo (Token thisToken, ...);
// functionHeader:
Token IntArray_delete (Token thisToken, ...);
// functionHeader:
Token IntArray_convert (Token thisToken, ...);
Token String_equals (Token thisToken, ...);
// functionHeader:
Token String_equals (Token thisToken, ...);
// functionHeader:
Token String_delete (Token thisToken, ...);
// functionHeader:
Token String_convert (Token thisToken, ...);
// functionHeader:
Token Int_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Int_convert (Token thisToken, ...);
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token Boolean_convert (Token thisToken, ...);
// functionHeader:
Token StringArray_isCloseTo (Token thisToken, ...);
// functionHeader:
Token StringArray_delete (Token thisToken, ...);
// functionHeader:
Token StringArray_convert (Token thisToken, ...);
/* We share one method between all scalar types so as to reduce code size. */
Token scalarDelete(Token token, ...) {
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
#define NUM_TYPE 6
#define NUM_FUNC 3
Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
{Double_isCloseTo, scalarDelete, Double_convert},
{IntArray_isCloseTo, IntArray_delete, IntArray_convert},
{String_equals, String_delete, String_convert},
{Int_isCloseTo, scalarDelete, Int_convert},
{Boolean_equals, scalarDelete, Boolean_convert},
{StringArray_isCloseTo, StringArray_delete, StringArray_convert}
};
char* toString_Pointer(void* p) {
    char* string = (char*) malloc(sizeof(char) * 31);
    sprintf(string, "Memory @ %.22o", (int) p);
    return string;
}
// IntArray_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token IntArray_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    result.type = TYPE_IntArray;
    result.payload.IntArray = (IntArrayToken) malloc(sizeof(struct intarray));
    result.payload.IntArray->size = size;
    result.payload.IntArray->elementType = TYPE_Int;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.IntArray->elements =
        (int *) calloc(size, sizeof(int));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.IntArray->elements[i] = (int) va_arg(argp, int);
            }
            va_end(argp);
        }
    }
    return result;
}
// StringArray_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token StringArray_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    result.type = TYPE_StringArray;
    result.payload.StringArray = (StringArrayToken) malloc(sizeof(struct stringarray));
    result.payload.StringArray->size = size;
    result.payload.StringArray->elementType = TYPE_String;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.StringArray->elements =
        (string *) calloc(size, sizeof(string));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.StringArray->elements[i] = (string) va_arg(argp, string);
            }
            va_end(argp);
        }
    }
    return result;
}
// make a new integer token from the given value.
Token Boolean_new(boolean b) {
    Token result;
    result.type = TYPE_Boolean;
    result.payload.Boolean = b;
    return result;
}
Token Double_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Double - otherToken.payload.Double) < tolerance.payload.Double);
}
/* Instead of Double_delete(), we call scalarDelete(). */
Token Double_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_String
        case TYPE_String:
        // FIXME: Is this safe?
        token.type = TYPE_Double;
        if (sscanf(token.payload.String, "%lg", &token.payload.Double) != 1) {
            fprintf(stderr, "Double_convert(): failed to convert \"%s\" to a Double\n", token.payload.String);
            exit(-1);
        }
        break;
        #endif
        #ifdef TYPE_Int
        case TYPE_Int:
        token.type = TYPE_Double;
        token.payload.Double = InttoDouble(token.payload.Int);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Double_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        exit(-1);
        break;
    }
    token.type = TYPE_Double;
    return token;
}
// IntArray_isCloseTo: Test an array to see whether it is close in value to another.
Token IntArray_isCloseTo(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    otherToken = IntArray_convert(otherToken);
    int value1, value2;
    tolerance = va_arg(argp, Token);
    if (thisToken.payload.IntArray->size != otherToken.payload.IntArray->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.IntArray->size; i++) {
        value1 = IntArray_get(thisToken, i);
        value2 = IntArray_get(otherToken, i);
        if (fabs(value1 - value2) > tolerance.payload.Double) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// IntArray_delete: FIXME: What does this do?
Token IntArray_delete(Token token, ...) {
    Token emptyToken;
    //Token element;
    //int i;
    //char elementType;
    // Delete each elements.
    // for (i = 0; i < token.payload.IntArray->size; i++) {
        //     elementType = token.payload.IntArray->elementType;
        //     element = IntArray_get(token, i);
        //     functionTable[(int) elementType][FUNC_delete](element);
    // }
    free((int *) token.payload.IntArray->elements);
    free(token.payload.IntArray);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
// IntArray_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token IntArray_convert(Token token, ...) {
    //    int i;
    //    Token result;
    //    Token element;
    //    va_list argp;
    //    char targetType;
    //
    //    va_start(argp, token);
    //    targetType = va_arg(argp, int);
    //
    //    // FIXME: HOW DO WE KNOW WHICH TYPE WE'RE CONVERTING TO?
    //    result = IntArray_new(token.payload.IntArray->size, 0);
    //
    //    for (i = 0; i < token.payload.IntArray->size; i++) {
        //        element = IntArray_get(token, i);
        //        if (targetType != token.payload.IntArray->elementType) {
            //
            //                IntArray_set(result, i, functionTable[(int)targetType][FUNC_convert](element));
            //            // result.payload.IntArray->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        //        } else {
            //                IntArray_set(result, i, element);
        //        }
    //    }
    //
    //    va_end(argp);
    //    return result;
    return token;
}
Token String_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(!strcmp(thisToken.payload.String, otherToken.payload.String));
}
Token String_delete(Token token, ...) {
    free(token.payload.String);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
Token String_convert(Token token, ...) {
    char* stringPointer;
    switch (token.type) {
        #ifdef TYPE_Boolean
        case TYPE_Boolean:
        stringPointer = BooleantoString(token.payload.Boolean);
        break;
        #endif
        #ifdef TYPE_Int
        case TYPE_Int:
        stringPointer = InttoString(token.payload.Int);
        break;
        #endif
        #ifdef TYPE_Double
        case TYPE_Double:
        stringPointer = DoubletoString(token.payload.Double);
        break;
        #endif
        default:
        // FIXME: not finished
        fprintf(stderr, "String_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        break;
    }
    token.payload.String = stringPointer;
    token.type = TYPE_String;
    return token;
}
Token Int_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Int - otherToken.payload.Int) < tolerance.payload.Double);
}
/* Instead of Int_delete(), we call scalarDelete(). */
Token Int_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_Double
        case TYPE_Double:
        token.payload.Int = DoubletoInt(token.payload.Double);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Int_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        break;
    }
    token.type = TYPE_Int;
    return token;
}
Token Boolean_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(( thisToken.payload.Boolean && otherToken.payload.Boolean ) ||
    ( !thisToken.payload.Boolean && !otherToken.payload.Boolean ));
}
/* Instead of Boolean_delete(), we call scalarDelete(). */
Token Boolean_convert(Token token, ...) {
    switch (token.type) {
        // FIXME: not finished
        default:
        fprintf(stderr, "Boolean_convert(): Conversion from an unsupported type. (%d)", token.type);
        break;
    }
    token.type = TYPE_Boolean;
    return token;
}
boolean equals_String_String(char* a1, char* a2) {
    return strcmp(a1, a2) == 0 ? true : false;
}
// StringArray_equals: Test an array for equality with a second array.
Token StringArray_equals(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    if (thisToken.payload.StringArray->size != otherToken.payload.StringArray->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.StringArray->size; i++) {
        if (!equals_String_String(StringArray_get(thisToken, i), StringArray_get(otherToken, i))) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// StringArray_isCloseTo: Test an array to see whether it is close in value to another.
Token StringArray_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return StringArray_equals(thisToken, otherToken);
}
// StringArray_delete: FIXME: What does this do?
Token StringArray_delete(Token token, ...) {
    Token emptyToken;
    //Token element;
    //int i;
    //char elementType;
    // Delete each elements.
    // for (i = 0; i < token.payload.StringArray->size; i++) {
        //     elementType = token.payload.StringArray->elementType;
        //     element = StringArray_get(token, i);
        //     functionTable[(int) elementType][FUNC_delete](element);
    // }
    free((string *) token.payload.StringArray->elements);
    free(token.payload.StringArray);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
// StringArray_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token StringArray_convert(Token token, ...) {
    //    int i;
    //    Token result;
    //    Token element;
    //    va_list argp;
    //    char targetType;
    //
    //    va_start(argp, token);
    //    targetType = va_arg(argp, int);
    //
    //    // FIXME: HOW DO WE KNOW WHICH TYPE WE'RE CONVERTING TO?
    //    result = StringArray_new(token.payload.StringArray->size, 0);
    //
    //    for (i = 0; i < token.payload.StringArray->size; i++) {
        //        element = StringArray_get(token, i);
        //        if (targetType != token.payload.StringArray->elementType) {
            //
            //                StringArray_set(result, i, functionTable[(int)targetType][FUNC_convert](element));
            //            // result.payload.StringArray->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        //        } else {
            //                StringArray_set(result, i, element);
        //        }
    //    }
    //
    //    va_end(argp);
    //    return result;
    return token;
}
/* end shared code */
/* SimplePassPointerTest_EmbeddedCActor's input variable declarations. */
static int SimplePassPointerTest_EmbeddedCActor_in;
/* SimplePassPointerTest_EmbeddedCActor's output variable declarations. */
static void* SimplePassPointerTest_EmbeddedCActor_ptr;
static int SimplePassPointerTest_EmbeddedCActor_value;
/* SimplePassPointerTest_EmbeddedCActor_EmbeddedActor's input variable declarations. */
static int SimplePassPointerTest_EmbeddedCActor_EmbeddedActor_in;
/* SimplePassPointerTest_EmbeddedCActor2's input variable declarations. */
static void* SimplePassPointerTest_EmbeddedCActor2_in;
/* SimplePassPointerTest_EmbeddedCActor2's output variable declarations. */
static void* SimplePassPointerTest_EmbeddedCActor2_ptr;
static int SimplePassPointerTest_EmbeddedCActor2_value;
/* SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor's input variable declarations. */
static void* SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor_in;
/* SimplePassPointerTest_Test's referenced parameter declarations. */
static Token SimplePassPointerTest_Test_correctValues_;
static double SimplePassPointerTest_Test_tolerance_;
/* SimplePassPointerTest_Test's input variable declarations. */
static int SimplePassPointerTest_Test_input[1];
/* SimplePassPointerTest_Test's output variable declarations. */
static boolean SimplePassPointerTest_Test_output;
/* SimplePassPointerTest_Test2's referenced parameter declarations. */
static double SimplePassPointerTest_Test2_tolerance_;
static Token SimplePassPointerTest_Test2_correctValues_;
/* SimplePassPointerTest_Test2's input variable declarations. */
static int SimplePassPointerTest_Test2_input[1];
/* SimplePassPointerTest_Test2's output variable declarations. */
static boolean SimplePassPointerTest_Test2_output;
/* SimplePassPointerTest_StringSubstring's referenced parameter declarations. */
static int SimplePassPointerTest_StringSubstring_start_;
static int SimplePassPointerTest_StringSubstring_stop_;
/* SimplePassPointerTest_StringSubstring's input variable declarations. */
static char* SimplePassPointerTest_StringSubstring_input;
/* SimplePassPointerTest_Test5's referenced parameter declarations. */
static Token SimplePassPointerTest_Test5_correctValues_;
/* SimplePassPointerTest_Test5's input variable declarations. */
static char* SimplePassPointerTest_Test5_input[1];
/* SimplePassPointerTest_Test5's output variable declarations. */
static boolean SimplePassPointerTest_Test5_output;
/* SimplePassPointerTest_StringSubstring2's referenced parameter declarations. */
static int SimplePassPointerTest_StringSubstring2_start_;
static int SimplePassPointerTest_StringSubstring2_stop_;
/* SimplePassPointerTest_StringSubstring2's input variable declarations. */
static char* SimplePassPointerTest_StringSubstring2_input;
/* SimplePassPointerTest_Test3's referenced parameter declarations. */
static Token SimplePassPointerTest_Test3_correctValues_;
/* SimplePassPointerTest_Test3's input variable declarations. */
static char* SimplePassPointerTest_Test3_input[1];
/* SimplePassPointerTest_Test3's output variable declarations. */
static boolean SimplePassPointerTest_Test3_output;
/* SimplePassPointerTest_TokenToExpression's input variable declarations. */
static void* SimplePassPointerTest_TokenToExpression_input;
/* SimplePassPointerTest_TokenToExpression2's input variable declarations. */
static void* SimplePassPointerTest_TokenToExpression2_input;
/* The preinitialization of the director. */
/* The preinitialization of the director. */
/* preinitEmbeddedActor */
int * SimplePassPointerTest_EmbeddedCActor_EmbeddedActor__ptr;
/* preinitTest */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int SimplePassPointerTest_Test__numberOfTokensSeen = -1;
int SimplePassPointerTest_Test__inputToken;
Token SimplePassPointerTest_Test__trainedValues;
/* preinitTest2 */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int SimplePassPointerTest_Test2__numberOfTokensSeen = -1;
int SimplePassPointerTest_Test2__inputToken;
Token SimplePassPointerTest_Test2__trainedValues;
/* preinitStringSubstring */
int SimplePassPointerTest_StringSubstring__length;
/* preinitTest5 */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int SimplePassPointerTest_Test5__numberOfTokensSeen = -1;
char* SimplePassPointerTest_Test5__inputToken;
Token SimplePassPointerTest_Test5__trainedValues;
/* preinitStringSubstring2 */
int SimplePassPointerTest_StringSubstring2__length;
/* preinitTest3 */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int SimplePassPointerTest_Test3__numberOfTokensSeen = -1;
char* SimplePassPointerTest_Test3__inputToken;
Token SimplePassPointerTest_Test3__trainedValues;
/* end preinitialize code */
/* before appending fireFunctionCode */
void SimplePassPointerTest_EmbeddedCActor_EmbeddedActor(void) {
    SimplePassPointerTest_EmbeddedCActor_ptr = SimplePassPointerTest_EmbeddedCActor_EmbeddedActor__ptr;
    SimplePassPointerTest_EmbeddedCActor_value = *SimplePassPointerTest_EmbeddedCActor_EmbeddedActor__ptr;
}
void SimplePassPointerTest_EmbeddedCActor(void) {
    /* SDFDirector: Transfer tokens to the inside. */
    SimplePassPointerTest_EmbeddedCActor_EmbeddedActor_in =
    SimplePassPointerTest_EmbeddedCActor_in;
    /* The firing of the StaticSchedulingDirector */
    SimplePassPointerTest_EmbeddedCActor_EmbeddedActor();
    /* SDFDirector: Transfer tokens to the outside. */
    SimplePassPointerTest_EmbeddedCActor2_in = SimplePassPointerTest_TokenToExpression2_input =
    SimplePassPointerTest_EmbeddedCActor_ptr;
    /* SDFDirector: Transfer tokens to the outside. */
    SimplePassPointerTest_Test_input[0] =
    SimplePassPointerTest_EmbeddedCActor_value;
}
void SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor(void) {
    SimplePassPointerTest_EmbeddedCActor2_ptr = SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor_in;
    SimplePassPointerTest_EmbeddedCActor2_value = *((int*) SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor_in);
}
void SimplePassPointerTest_EmbeddedCActor2(void) {
    /* SDFDirector: Transfer tokens to the inside. */
    SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor_in =
    SimplePassPointerTest_EmbeddedCActor2_in;
    /* The firing of the StaticSchedulingDirector */
    SimplePassPointerTest_EmbeddedCActor2_EmbeddedActor();
    /* SDFDirector: Transfer tokens to the outside. */
    SimplePassPointerTest_TokenToExpression_input =
    SimplePassPointerTest_EmbeddedCActor2_ptr;
    /* SDFDirector: Transfer tokens to the outside. */
    SimplePassPointerTest_Test2_input[0] =
    SimplePassPointerTest_EmbeddedCActor2_value;
}
void SimplePassPointerTest_Const(void) {
    SimplePassPointerTest_EmbeddedCActor_in = 1;
}
void SimplePassPointerTest_Test(void) {
    SimplePassPointerTest_Test__inputToken = SimplePassPointerTest_Test_input[0];
    SimplePassPointerTest_Test__numberOfTokensSeen++;
    /* SimplePassPointerTest_Test_, IntBlock(0) which has only one channel */
    if (SimplePassPointerTest_Test__numberOfTokensSeen < 1
    && fabs(SimplePassPointerTest_Test__inputToken
    - /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test_correctValues_ , SimplePassPointerTest_Test__numberOfTokensSeen))
    > SimplePassPointerTest_Test_tolerance_) {
        printf("\nTest SimplePassPointerTest_Test__0 fails in iteration %d.\n Value was: %d. Should have been between: %10.30g and %10.30g\n",
        SimplePassPointerTest_Test__numberOfTokensSeen,
        SimplePassPointerTest_Test__inputToken,
        /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test_correctValues_ , SimplePassPointerTest_Test__numberOfTokensSeen) -
        SimplePassPointerTest_Test_tolerance_,
        /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test_correctValues_ , SimplePassPointerTest_Test__numberOfTokensSeen) +
        SimplePassPointerTest_Test_tolerance_);
        exit(-1);
    }
}
void SimplePassPointerTest_Test2(void) {
    SimplePassPointerTest_Test2__inputToken = SimplePassPointerTest_Test2_input[0];
    SimplePassPointerTest_Test2__numberOfTokensSeen++;
    /* SimplePassPointerTest_Test2_, IntBlock(0) which has only one channel */
    if (SimplePassPointerTest_Test2__numberOfTokensSeen < 1
    && fabs(SimplePassPointerTest_Test2__inputToken
    - /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test2_correctValues_ , SimplePassPointerTest_Test2__numberOfTokensSeen))
    > SimplePassPointerTest_Test2_tolerance_) {
        printf("\nTest SimplePassPointerTest_Test2__0 fails in iteration %d.\n Value was: %d. Should have been between: %10.30g and %10.30g\n",
        SimplePassPointerTest_Test2__numberOfTokensSeen,
        SimplePassPointerTest_Test2__inputToken,
        /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test2_correctValues_ , SimplePassPointerTest_Test2__numberOfTokensSeen) -
        SimplePassPointerTest_Test2_tolerance_,
        /*CGH77*//*CGH77*/IntArray_get(SimplePassPointerTest_Test2_correctValues_ , SimplePassPointerTest_Test2__numberOfTokensSeen) +
        SimplePassPointerTest_Test2_tolerance_);
        exit(-1);
    }
}
void SimplePassPointerTest_StringSubstring(void) {
    SimplePassPointerTest_StringSubstring__length = SimplePassPointerTest_StringSubstring_stop_ - SimplePassPointerTest_StringSubstring_start_;
    /* Realloc space for the null */
    SimplePassPointerTest_Test5_input[0] = (char*) realloc(SimplePassPointerTest_Test5_input[0], SimplePassPointerTest_StringSubstring__length + 1);
    SimplePassPointerTest_Test5_input[0] = strncpy(SimplePassPointerTest_Test5_input[0], SimplePassPointerTest_StringSubstring_input + SimplePassPointerTest_StringSubstring_start_, SimplePassPointerTest_StringSubstring__length);
    /* Solaris: strncpy does not add a null if only n chars are copied. */
    SimplePassPointerTest_Test5_input[0][SimplePassPointerTest_StringSubstring__length] = '\0';
}
void SimplePassPointerTest_Test5(void) {
    SimplePassPointerTest_Test5__inputToken = SimplePassPointerTest_Test5_input[0];
    SimplePassPointerTest_Test5__numberOfTokensSeen++;
    if (SimplePassPointerTest_Test5__numberOfTokensSeen < 1
    && (strcmp(/*CGH77*//*CGH77*/StringArray_get(SimplePassPointerTest_Test5_correctValues_ , SimplePassPointerTest_Test5__numberOfTokensSeen),
    SimplePassPointerTest_Test5__inputToken) != 0) ) {
        printf("\nTest SimplePassPointerTest_Test5__0 fails in iteration %d.\n Value was a String: \"%s\". Should have been a String: \"%s\"\n",
        SimplePassPointerTest_Test5__numberOfTokensSeen,
        SimplePassPointerTest_Test5__inputToken,
        /*CGH77*//*CGH77*/StringArray_get(SimplePassPointerTest_Test5_correctValues_ , SimplePassPointerTest_Test5__numberOfTokensSeen));
        exit(-1);
    }
}
void SimplePassPointerTest_StringSubstring2(void) {
    SimplePassPointerTest_StringSubstring2__length = SimplePassPointerTest_StringSubstring2_stop_ - SimplePassPointerTest_StringSubstring2_start_;
    /* Realloc space for the null */
    SimplePassPointerTest_Test3_input[0] = (char*) realloc(SimplePassPointerTest_Test3_input[0], SimplePassPointerTest_StringSubstring2__length + 1);
    SimplePassPointerTest_Test3_input[0] = strncpy(SimplePassPointerTest_Test3_input[0], SimplePassPointerTest_StringSubstring2_input + SimplePassPointerTest_StringSubstring2_start_, SimplePassPointerTest_StringSubstring2__length);
    /* Solaris: strncpy does not add a null if only n chars are copied. */
    SimplePassPointerTest_Test3_input[0][SimplePassPointerTest_StringSubstring2__length] = '\0';
}
void SimplePassPointerTest_Test3(void) {
    SimplePassPointerTest_Test3__inputToken = SimplePassPointerTest_Test3_input[0];
    SimplePassPointerTest_Test3__numberOfTokensSeen++;
    if (SimplePassPointerTest_Test3__numberOfTokensSeen < 1
    && (strcmp(/*CGH77*//*CGH77*/StringArray_get(SimplePassPointerTest_Test3_correctValues_ , SimplePassPointerTest_Test3__numberOfTokensSeen),
    SimplePassPointerTest_Test3__inputToken) != 0) ) {
        printf("\nTest SimplePassPointerTest_Test3__0 fails in iteration %d.\n Value was a String: \"%s\". Should have been a String: \"%s\"\n",
        SimplePassPointerTest_Test3__numberOfTokensSeen,
        SimplePassPointerTest_Test3__inputToken,
        /*CGH77*//*CGH77*/StringArray_get(SimplePassPointerTest_Test3_correctValues_ , SimplePassPointerTest_Test3__numberOfTokensSeen));
        exit(-1);
    }
}
void SimplePassPointerTest_TokenToExpression(void) {
    // FIXME: is this the proper way to free the allocated space?
    //free(SimplePassPointerTest_StringSubstring_input);
    SimplePassPointerTest_StringSubstring_input = toString_Pointer(SimplePassPointerTest_TokenToExpression_input);
}
void SimplePassPointerTest_TokenToExpression2(void) {
    // FIXME: is this the proper way to free the allocated space?
    //free(SimplePassPointerTest_StringSubstring2_input);
    SimplePassPointerTest_StringSubstring2_input = toString_Pointer(SimplePassPointerTest_TokenToExpression2_input);
}
void SimplePassPointerTest(void) {
    /* The firing of the StaticSchedulingDirector */
    SimplePassPointerTest_Const();
    SimplePassPointerTest_EmbeddedCActor();
    SimplePassPointerTest_Test();
    SimplePassPointerTest_TokenToExpression2();
    SimplePassPointerTest_StringSubstring2();
    SimplePassPointerTest_Test3();
    SimplePassPointerTest_EmbeddedCActor2();
    SimplePassPointerTest_Test2();
    SimplePassPointerTest_TokenToExpression();
    SimplePassPointerTest_StringSubstring();
    SimplePassPointerTest_Test5();
}
/* after appending fireFunctionCode */
void initialize(void) {
    /* Test's parameter initialization */
    SimplePassPointerTest_Test_correctValues_ = IntArray_new(1, 1, 199);
    SimplePassPointerTest_Test_tolerance_ = 1.0E-9;
    /* Test2's parameter initialization */
    SimplePassPointerTest_Test2_tolerance_ = 1.0E-9;
    SimplePassPointerTest_Test2_correctValues_ = IntArray_new(1, 1, 199);
    /* StringSubstring's parameter initialization */
    SimplePassPointerTest_StringSubstring_start_ = 0;
    SimplePassPointerTest_StringSubstring_stop_ = 8;
    /* Test5's parameter initialization */
    SimplePassPointerTest_Test5_correctValues_ = StringArray_new(1, 1, "Memory @");
    /* StringSubstring2's parameter initialization */
    SimplePassPointerTest_StringSubstring2_start_ = 0;
    SimplePassPointerTest_StringSubstring2_stop_ = 8;
    /* Test3's parameter initialization */
    SimplePassPointerTest_Test3_correctValues_ = StringArray_new(1, 1, "Memory @");
    /* The initialization of the director. */
    /* The initialization of the director. */
    /* initEmbeddedActor */
    SimplePassPointerTest_EmbeddedCActor_EmbeddedActor__ptr = (int *) malloc(sizeof(int));
    *SimplePassPointerTest_EmbeddedCActor_EmbeddedActor__ptr = 199;
    /* The initialization of the director. */
    /* initStringSubstring */
    SimplePassPointerTest_Test5_input[0] = NULL;
    /* initStringSubstring2 */
    SimplePassPointerTest_Test3_input[0] = NULL;
}
void wrapup(void) {
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* wrapupTest */
    if ((SimplePassPointerTest_Test__numberOfTokensSeen + 1) < 1) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", SimplePassPointerTest_Test__numberOfTokensSeen, 1);
        exit(-2);
    }
    /* wrapupTest2 */
    if ((SimplePassPointerTest_Test2__numberOfTokensSeen + 1) < 1) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", SimplePassPointerTest_Test2__numberOfTokensSeen, 1);
        exit(-2);
    }
    /* wrapupTest5 */
    if ((SimplePassPointerTest_Test5__numberOfTokensSeen + 1) < 1) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", SimplePassPointerTest_Test5__numberOfTokensSeen, 1);
        exit(-2);
    }
    /* wrapupTest3 */
    if ((SimplePassPointerTest_Test3__numberOfTokensSeen + 1) < 1) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", SimplePassPointerTest_Test3__numberOfTokensSeen, 1);
        exit(-2);
    }
}
int main(int argc, char *argv[]) {
    initialize();
    int iteration;
    for (iteration = 0; iteration < 1; iteration ++) {
        /* The firing of the StaticSchedulingDirector */
        SimplePassPointerTest_Const();
        SimplePassPointerTest_EmbeddedCActor();
        SimplePassPointerTest_Test();
        SimplePassPointerTest_TokenToExpression2();
        SimplePassPointerTest_StringSubstring2();
        SimplePassPointerTest_Test3();
        SimplePassPointerTest_EmbeddedCActor2();
        SimplePassPointerTest_Test2();
        SimplePassPointerTest_TokenToExpression();
        SimplePassPointerTest_StringSubstring();
        SimplePassPointerTest_Test5();
        /* The postfire of the director. */
        /* The postfire of the director. */
        /* The postfire of the director. */
        /* postfireTest */
        // FIXME: should we update this here?
        //SimplePassPointerTest_Test__numberOfTokensSeen++;
        /* postfireTest2 */
        // FIXME: should we update this here?
        //SimplePassPointerTest_Test2__numberOfTokensSeen++;
        /* postfireTest5 */
        // FIXME: should we update this here?
        //SimplePassPointerTest_Test5__numberOfTokensSeen++;
        /* postfireTest3 */
        // FIXME: should we update this here?
        //SimplePassPointerTest_Test3__numberOfTokensSeen++;
    }
    wrapup();
    exit(0);
}
