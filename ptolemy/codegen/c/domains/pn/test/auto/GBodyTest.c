/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2009 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
#ifndef PT_NO_MATH_H
#include <math.h>
#endif
#ifndef PT_NO_STRING_H
#include <string.h>
#endif
#ifndef PT_NO_STDIO_H
#include <stdio.h>
#endif
#ifndef PT_NO_STDLIB_H
#include <stdlib.h>
#endif
#ifndef PT_NO_STDARG_H
#include <stdarg.h>
#endif
/* Generate type resolution code for .GBodyTest */
// Constants.
#define MISSING 0
typedef unsigned char boolean;
typedef char* string;
/* Infinity is a valid Ptolemy identifier. */
#define Infinity HUGE_VAL
#ifdef linux
/* Linux tends to have NAN. */
#define NaN (__builtin_nanf (""))
#else /*linux*/
#define NaN nanf(0)
#endif /*linux*/
#define false 0
#define true 1
#define TYPE_Token -1
#define TYPE_Double 0
#define TYPE_IntArray 1
#define TYPE_String 2
#define TYPE_Array 3
#define TYPE_DoubleArray 4
#define TYPE_Int 5
#define TYPE_Boolean 6
#define FUNC_isCloseTo 0
#define FUNC_delete 1
#define FUNC_convert 2
#define FUNC_toString 3
typedef struct token Token;
typedef double DoubleToken;
Token IntArray_new(int size, int given, ...);
struct intarray {
    int size;                                   // size of the array.
    int* elements;                            // array of Token elements.
    char elementType;                                 // type of the elements.
};
typedef struct intarray* IntArrayToken;
typedef char* StringToken;
// Definition of the array struct.
struct array {
    int size;                                   // size of the array.
    Token* elements;                            // array of Token elements.
    //char elementType;                          // type of the elements.
};
typedef struct array* ArrayToken;
Token DoubleArray_new(int size, int given, ...);
struct doublearray {
    int size;                                   // size of the array.
    double* elements;                            // array of Token elements.
    char elementType;                                 // type of the elements.
};
typedef struct doublearray* DoubleArrayToken;
typedef int IntToken;
typedef boolean BooleanToken;
// Token structure containing the specified types.
struct token {         // Base type for tokens.
    char type;         // TYPE field has to be the first field.
    union typeMembers {
        // type member declarations [i.e. Type1Token Type1;]
        DoubleToken Double;
        IntArrayToken IntArray;
        StringToken String;
        ArrayToken Array;
        DoubleArrayToken DoubleArray;
        IntToken Int;
        BooleanToken Boolean;
    } payload;
};
Token emptyToken; /* Used by *_delete() and others. */
Token Double_new(double d);
// IntArray_get: get an element of an array.
#define IntArray_length(array) ((array).payload.IntArray->size)
int IntArray_get(Token array, int i) {
    // Token result;
    // result.type = array.payload.IntArray->elementType;
    // result.payload.Int = ((int *) array.payload.IntArray->elements)[i];
    // return result;
    return ((int *) array.payload.IntArray->elements)[i];
}
// IntArray_set: set an element of an array.
void IntArray_set(Token array, int i, int element) {
    ((int *) array.payload.IntArray->elements)[i] = element;
}
// IntArray_resize: Change the size of an array,
// preserving those elements that fit.
void IntArray_resize(Token array, int size) {
    array.payload.IntArray->size = size;
    array.payload.IntArray->elements = (int*) realloc(
    array.payload.IntArray->elements, size * sizeof(int));
}
// IntArray_insert: Append the specified element to the end of an array.
void IntArray_insert(Token array, int token) {
    int oldSize = array.payload.IntArray->size++;
    IntArray_resize(array, array.payload.IntArray->size);
    ((int *) array.payload.IntArray->elements)[oldSize] = token;
}
Token String_new(char* s);
Token Array_new(int size, int given, ...);
// Array_get: get an element of an array.
Token Array_get(Token array, int i) {
    return array.payload.Array->elements[i];
}
// Array_set: set an element of an array.
void Array_set(Token array, int i, Token element) {
    array.payload.Array->elements[i] = element;
}
// Array_resize: Change the size of an array,
// preserving those elements that fit.
void Array_resize(Token array, int size) {
    array.payload.Array->size = size;
    // FIXME: Does realloc() initialize memory? If not, then we need to do that.
    array.payload.Array->elements = (Token*) realloc(array.payload.Array->elements, size * sizeof(Token));
}
// Array_insert: Append the specified element to the end of an array.
void Array_insert(Token array, Token token) {
    int oldSize = array.payload.Array->size++;
    Array_resize(array, array.payload.Array->size);
    array.payload.Array->elements[oldSize] = token;
}
#define Array_length(array) ((array).payload.Array->size)
// DoubleArray_get: get an element of an array.
#define DoubleArray_length(array) ((array).payload.DoubleArray->size)
double DoubleArray_get(Token array, int i) {
    // Token result;
    // result.type = array.payload.DoubleArray->elementType;
    // result.payload.Double = ((double *) array.payload.DoubleArray->elements)[i];
    // return result;
    return ((double *) array.payload.DoubleArray->elements)[i];
}
// DoubleArray_set: set an element of an array.
void DoubleArray_set(Token array, int i, double element) {
    ((double *) array.payload.DoubleArray->elements)[i] = element;
}
// DoubleArray_resize: Change the size of an array,
// preserving those elements that fit.
void DoubleArray_resize(Token array, int size) {
    array.payload.DoubleArray->size = size;
    array.payload.DoubleArray->elements = (double*) realloc(
    array.payload.DoubleArray->elements, size * sizeof(double));
}
// DoubleArray_insert: Append the specified element to the end of an array.
void DoubleArray_insert(Token array, double token) {
    int oldSize = array.payload.DoubleArray->size++;
    DoubleArray_resize(array, array.payload.DoubleArray->size);
    ((double *) array.payload.DoubleArray->elements)[oldSize] = token;
}
Token Int_new(int i);
Token Boolean_new(boolean b);
#define StringtoInt atoi
#define StringtoDouble atof
#define StringtoLong atol
#define DoubletoInt (int)
#define InttoDouble (double)
#define InttoLong (long)
char* InttoString (int i) {
    char* string = (char*) malloc(sizeof(char) * 12);
    sprintf((char*) string, "%d", i);
    return string;
}
char* LongtoString (long long l) {
    char* string = (char*) malloc(sizeof(char) * 22);
    sprintf(string, "%lld", l);
    return string;
}
char* DoubletoString (double d) {
    int index;
    char* string = (char*) malloc(sizeof(char) * 20);
    sprintf(string, "%.14g", d);
    // Make sure that there is a decimal point.
    if (strrchr(string, '.') == NULL) {
        index = strlen(string);
        if (index == 20) {
            string = (char*) realloc(string, sizeof(char) * 22);
        }
        string[index] = '.';
        string[index + 1] = '0';
        string[index + 2] = '\0';
    }
    return string;
}
char* BooleantoString (boolean b) {
    char *results;
    if (b) {
        // AVR does not have strdup
        results = (char*) malloc(sizeof(char) * 5);
        strcpy(results, "true");
    } else {
        results = (char*) malloc(sizeof(char) * 6);
        strcpy(results, "false");
    }
    return results;
}
char* UnsignedBytetoString (unsigned char b) {
    char* string = (char*) malloc(sizeof(char) * 3);
    sprintf(string, "%d", (int) b);
    return string;
}
// functionHeader:
Token Double_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Double_convert (Token thisToken, ...);
// functionHeader:
Token Double_toString (Token thisToken, ...);
// functionHeader:
Token IntArray_isCloseTo (Token thisToken, ...);
// functionHeader:
Token IntArray_delete (Token thisToken, ...);
// functionHeader:
Token IntArray_convert (Token thisToken, ...);
// functionHeader:
Token IntArray_toString (Token thisToken, ...);
Token String_equals (Token thisToken, ...);
// functionHeader:
Token String_equals (Token thisToken, ...);
// functionHeader:
Token String_delete (Token thisToken, ...);
// functionHeader:
Token String_convert (Token thisToken, ...);
// functionHeader:
Token String_toString (Token thisToken, ...);
// functionHeader:
Token Array_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Array_delete (Token thisToken, ...);
// functionHeader:
Token Array_convert (Token thisToken, ...);
// functionHeader:
Token Array_toString (Token thisToken, ...);
// functionHeader:
Token DoubleArray_isCloseTo (Token thisToken, ...);
// functionHeader:
Token DoubleArray_delete (Token thisToken, ...);
// functionHeader:
Token DoubleArray_convert (Token thisToken, ...);
// functionHeader:
Token DoubleArray_toString (Token thisToken, ...);
// functionHeader:
Token Int_isCloseTo (Token thisToken, ...);
// functionHeader:
Token Int_convert (Token thisToken, ...);
// functionHeader:
Token Int_toString (Token thisToken, ...);
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token Boolean_equals (Token thisToken, ...);
// functionHeader:
Token Boolean_convert (Token thisToken, ...);
// functionHeader:
Token Boolean_toString (Token thisToken, ...);
/* We share one method between all scalar types so as to reduce code size. */
Token scalarDelete(Token token, ...) {
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
#define NUM_TYPE 7
#define NUM_FUNC 4
Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
{Double_isCloseTo, scalarDelete, Double_convert, Double_toString},
{IntArray_isCloseTo, IntArray_delete, IntArray_convert, IntArray_toString},
{String_equals, String_delete, String_convert, String_toString},
{Array_isCloseTo, Array_delete, Array_convert, Array_toString},
{DoubleArray_isCloseTo, DoubleArray_delete, DoubleArray_convert, DoubleArray_toString},
{Int_isCloseTo, scalarDelete, Int_convert, Int_toString},
{Boolean_equals, scalarDelete, Boolean_convert, Boolean_toString}
};
// IntArray_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token IntArray_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    result.type = TYPE_IntArray;
    result.payload.IntArray = (IntArrayToken) malloc(sizeof(struct intarray));
    result.payload.IntArray->size = size;
    result.payload.IntArray->elementType = TYPE_Int;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.IntArray->elements =
        (int *) calloc(size, sizeof(int));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.IntArray->elements[i] = (int) va_arg(argp, int);
            }
            va_end(argp);
        }
    }
    return result;
}
// DoubleArray_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token DoubleArray_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    result.type = TYPE_DoubleArray;
    result.payload.DoubleArray = (DoubleArrayToken) malloc(sizeof(struct doublearray));
    result.payload.DoubleArray->size = size;
    result.payload.DoubleArray->elementType = TYPE_Double;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.DoubleArray->elements =
        (double *) calloc(size, sizeof(double));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.DoubleArray->elements[i] = (double) va_arg(argp, double);
            }
            va_end(argp);
        }
    }
    return result;
}
Token convert_IntArray_DoubleArray(Token token) {
    int i;
    int length = token.payload.IntArray->size;
    Token result = DoubleArray_new(length, 0);
    for (i = 0; i < length; i++) {
        DoubleArray_set(result, i, (double) IntArray_get(token, i));
    }
    return result;
}
double zero_Double() {
    return 0.0;
}
Token convert_Double_DoubleArray(double a) {
    return DoubleArray_new(1, 1, a);
}
// make a new integer token from the given value.
Token Double_new(double d) {
    Token result;
    result.type = TYPE_Double;
    result.payload.Double = d;
    return result;
}
double multiply_Double_Double(double a1, double a2) {
    return a1 * a2;
}
Token multiply_DoubleArray_Double(Token a1, double a2) {
    int i;
    Token result = DoubleArray_new(a1.payload.DoubleArray->size, 0);
    for (i = 0; i < a1.payload.DoubleArray->size; i++) {
        DoubleArray_set(result, i, multiply_Double_Double(DoubleArray_get(a1, i), a2));
    }
    return result;
}
int subtract_Int_Int(int a1, int a2) {
    return a1 - a2;
}
// IntArray_subtract: Subtract the second argument array
// from the first argument array.
// Assume the given otherToken is an array.
// FIXME: Arrays can have scalars subtracted!
// This will cause a nasty seg fault.
// Return a new Array token.
Token IntArray_subtract(Token thisToken, ...) {
    int i;
    int size1;
    int size2;
    int resultSize;
    va_list argp;
    Token result;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    size1 = thisToken.payload.IntArray->size;
    size2 = otherToken.payload.IntArray->size;
    resultSize = (size1 > size2) ? size1 : size2;
    result = IntArray_new(resultSize, 0);
    for (i = 0; i < resultSize; i++) {
        if (size1 == 1) {
            IntArray_set(result, i, subtract_Int_Int(IntArray_get(thisToken, 0),IntArray_get(otherToken, i)));
        } else if (size2 == 1) {
            IntArray_set(result, i, subtract_Int_Int(IntArray_get(thisToken, i),IntArray_get(otherToken, 0)));
        } else {
            IntArray_set(result, i, subtract_Int_Int(IntArray_get(thisToken, i),IntArray_get(otherToken, i)));
        }
    }
    va_end(argp);
    return result;
}
Token subtract_IntArray_IntArray(Token a1, Token a2) {
    return IntArray_subtract(a1, a2);
}
int multiply_Int_Int(int a1, int a2) {
    return a1 * a2;
}
// IntArray_multiply: Multiply an array by another array.
// Multiplication is element-wise.
// Assume the given otherToken is array type.
// Return a new Array token.
Token IntArray_multiply(Token thisToken, ...) {
    int i;
    int size1;
    int size2;
    int resultSize;
    va_list argp;
    Token result;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    size1 = thisToken.payload.IntArray->size;
    size2 = otherToken.payload.IntArray->size;
    resultSize = (size1 > size2) ? size1 : size2;
    result = IntArray_new(resultSize, 0);
    for (i = 0; i < resultSize; i++) {
        if (size1 == 1) {
            IntArray_set(result, i, multiply_Int_Int(IntArray_get(thisToken, 0),IntArray_get(otherToken, i)));
        } else if (size2 == 1) {
            IntArray_set(result, i, multiply_Int_Int(IntArray_get(thisToken, i),IntArray_get(otherToken, 0)));
        } else {
            IntArray_set(result, i, multiply_Int_Int(IntArray_get(thisToken, i),IntArray_get(otherToken, i)));
        }
    }
    va_end(argp);
    return result;
}
Token multiply_IntArray_IntArray(Token a1, Token a2) {
    return IntArray_multiply(a1, a2);
}
int add_Int_Int(int a1, int a2) {
    return a1 + a2;
}
// FIXME: WHAT DOES THIS FUNCTION DO?
int IntArray_sum(Token token) {
    int result;
    int i;
    if (token.payload.IntArray->size <= 0) {
        return 0;
    } else {
        result = IntArray_get(token, 0);
    }
    for (i = 1; i < token.payload.IntArray->size; i++) {
        result = add_Int_Int(result, IntArray_get(token, i));
    }
    return result;
}
double add_Double_Double(double a1, double a2) {
    return a1 + a2;
}
// DoubleArray_add: Add an array to another array.
// Assume the given otherToken is array type.
// Return a new Array token.
Token DoubleArray_add(Token thisToken, ...) {
    int i;
    int size1;
    int size2;
    int resultSize;
    va_list argp;
    Token result;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    size1 = thisToken.payload.DoubleArray->size;
    size2 = otherToken.payload.DoubleArray->size;
    resultSize = (size1 > size2) ? size1 : size2;
    result = DoubleArray_new(resultSize, 0);
    for (i = 0; i < resultSize; i++) {
        if (size1 == 1) {
            DoubleArray_set(result, i, add_Double_Double(DoubleArray_get(thisToken, 0),DoubleArray_get(otherToken, i)));
        } else if (size2 == 1) {
            DoubleArray_set(result, i, add_Double_Double(DoubleArray_get(thisToken, i),DoubleArray_get(otherToken, 0)));
        } else {
            DoubleArray_set(result, i, add_Double_Double(DoubleArray_get(thisToken, i),DoubleArray_get(otherToken, i)));
        }
    }
    va_end(argp);
    return result;
}
Token add_DoubleArray_DoubleArray(Token a1, Token a2) {
    return DoubleArray_add(a1, a2);
}
inline double divide_Double_Double(double a1, double a2) {
    return a1 / a2;
}
Token divide_DoubleArray_Double(Token a1, double a2) {
    int i;
    Token result = DoubleArray_new(a1.payload.DoubleArray->size, 0);
    for (i = 0; i < a1.payload.DoubleArray->size; i++) {
        DoubleArray_set(result, i, divide_Double_Double(DoubleArray_get(a1, i), a2));
    }
    return result;
}
#define multiply_Double_DoubleArray(a1, a2) multiply_DoubleArray_Double(a2, a1)
// Array_new: Create a new array with the specified elements.
//  The "size" argument specifies the size of the array, and
// the "given" argument specifies the number of provided elements
// (which will typically be <= size).
// The rest of the arguments are the provided elements (there
// should be "given" of them). The given elements
// should be of type Token *.
// If the "given" argument is greater than 0, then the last
// argument is expected to be the type that of the elements.
Token Array_new(int size, int given, ...) {
    va_list argp;
    int i;
    Token result;
    //        char elementType;
    result.type = TYPE_Array;
    result.payload.Array = (ArrayToken) malloc(sizeof(struct array));
    result.payload.Array->size = size;
    // Only call calloc if size > 0.  Otherwise Electric Fence reports
    // an error.
    if (size > 0) {
        // Allocate an new array of Tokens.
        result.payload.Array->elements = (Token*) calloc(size, sizeof(Token));
        if (given > 0) {
            va_start(argp, given);
            for (i = 0; i < given; i++) {
                result.payload.Array->elements[i] = va_arg(argp, Token);
            }
            // elementType is given as the last argument.
            //                        elementType = va_arg(argp, int);
            //                        //result.payload.Array->elementType = elementType;
            //
            //                        if (elementType >= 0) {
                //                                // convert the elements if needed.
                //                                for (i = 0; i < given; i++) {
                    //                                        if (Array_get(result, i).type != elementType) {
                        //                                                Array_set(result, i, functionTable[(int)elementType][FUNC_convert](Array_get(result, i)));
                    //                                        }
                //                                }
            //                        }
            va_end(argp);
        }
    }
    return result;
}
Token DoubleArray_repeat(int number, double value) {
    Token result;
    result = DoubleArray_new(number, 0);
    int i;
    for (i = 0; i < number; i++) {
        DoubleArray_set(result, i, value);
    }
    return result;
}
// make a new integer token from the given value.
Token Boolean_new(boolean b) {
    Token result;
    result.type = TYPE_Boolean;
    result.payload.Boolean = b;
    return result;
}
Token Double_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Double - otherToken.payload.Double) < tolerance.payload.Double);
}
/* Instead of Double_delete(), we call scalarDelete(). */
Token Double_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_String
        case TYPE_String:
        // FIXME: Is this safe?
        token.type = TYPE_Double;
        if (sscanf(token.payload.String, "%lg", &token.payload.Double) != 1) {
            fprintf(stderr, "Double_convert(): failed to convert \"%s\" to a Double\n", token.payload.String);
            exit(-1);
        }
        break;
        #endif
        #ifdef TYPE_Int
        case TYPE_Int:
        token.type = TYPE_Double;
        token.payload.Double = InttoDouble(token.payload.Int);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Double_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        exit(-1);
        break;
    }
    token.type = TYPE_Double;
    return token;
}
char* toString_Double(double d) {
    int index;
    char* string = (char*) malloc(sizeof(char) * 20);
    sprintf(string, "%.14g", d);
    // Make sure that there is a decimal point.
    if (strrchr(string, '.') == NULL) {
        index = strlen(string);
        if (index == 20) {
            string = (char*) realloc(string, sizeof(char) * 22);
        }
        string[index] = '.';
        string[index + 1] = '0';
        string[index + 2] = '\0';
    }
    return string;
}
/* Make a new integer token from the given value. */
Token String_new(char* s) {
    Token result;
    result.type = TYPE_String;
    result.payload.String = strdup(s);
    return result;
}
Token Double_toString(Token thisToken, ...) {
    return String_new(toString_Double(thisToken.payload.Double));
}
// IntArray_isCloseTo: Test an array to see whether it is close in value to another.
Token IntArray_isCloseTo(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    otherToken = IntArray_convert(otherToken);
    int value1, value2;
    tolerance = va_arg(argp, Token);
    if (thisToken.payload.IntArray->size != otherToken.payload.IntArray->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.IntArray->size; i++) {
        value1 = IntArray_get(thisToken, i);
        value2 = IntArray_get(otherToken, i);
        if (fabs(value1 - value2) > tolerance.payload.Double) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// IntArray_delete: FIXME: What does this do?
Token IntArray_delete(Token token, ...) {
    Token emptyToken;
    //Token element;
    //int i;
    //char elementType;
    // Delete each elements.
    // for (i = 0; i < token.payload.IntArray->size; i++) {
        //     elementType = token.payload.IntArray->elementType;
        //     element = IntArray_get(token, i);
        //     functionTable[(int) elementType][FUNC_delete](element);
    // }
    free((int *) token.payload.IntArray->elements);
    free(token.payload.IntArray);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
// IntArray_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token IntArray_convert(Token token, ...) {
    //    int i;
    //    Token result;
    //    Token element;
    //    va_list argp;
    //    char targetType;
    //
    //    va_start(argp, token);
    //    targetType = va_arg(argp, int);
    //
    //    // FIXME: HOW DO WE KNOW WHICH TYPE WE'RE CONVERTING TO?
    //    result = IntArray_new(token.payload.IntArray->size, 0);
    //
    //    for (i = 0; i < token.payload.IntArray->size; i++) {
        //        element = IntArray_get(token, i);
        //        if (targetType != token.payload.IntArray->elementType) {
            //
            //                IntArray_set(result, i, functionTable[(int)targetType][FUNC_convert](element));
            //            // result.payload.IntArray->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        //        } else {
            //                IntArray_set(result, i, element);
        //        }
    //    }
    //
    //    va_end(argp);
    //    return result;
    return token;
}
char* toString_IntArray(Token thisToken) {
    int i;
    int currentSize, allocatedSize;
    char* string;
    char elementString[12];
    allocatedSize = 256;
    string = (char*) malloc(allocatedSize);
    string[0] = '{';
        string[1] = '\0';
    // Space for '{', '}', and '\0' characters.
        currentSize = 3;
        //printf("%d\n", thisToken.payload.IntArray->size);
        for (i = 0; i < thisToken.payload.IntArray->size; i++) {
            // Calculate the require storage size.
            // int temp = IntArray_get(thisToken, i);
            sprintf(elementString, "%d", IntArray_get(thisToken, i));
            currentSize += strlen(elementString);
            if (i != 0) {
                currentSize += 2;
            }
            // Re-allocate storage.
            if (currentSize > allocatedSize) {
                allocatedSize *= 2;
                string = (char*) realloc(string, allocatedSize);
            }
            // Concat the element strings and separators.
            if (i != 0) {
                strcat(string, ", ");
            }
            strcat(string, elementString);
        }
    strcat(string, "}");
    return string;
}
// IntArray_toString: Return a string token with a string representation
// of the specified array.
Token IntArray_toString(Token thisToken, ...) {
    return String_new(toString_IntArray(thisToken));
}
Token String_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(!strcmp(thisToken.payload.String, otherToken.payload.String));
}
Token String_delete(Token token, ...) {
    free(token.payload.String);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
Token String_convert(Token token, ...) {
    char* stringPointer;
    switch (token.type) {
        #ifdef TYPE_Boolean
        case TYPE_Boolean:
        stringPointer = BooleantoString(token.payload.Boolean);
        break;
        #endif
        #ifdef TYPE_Int
        case TYPE_Int:
        stringPointer = InttoString(token.payload.Int);
        break;
        #endif
        #ifdef TYPE_Double
        case TYPE_Double:
        stringPointer = DoubletoString(token.payload.Double);
        break;
        #endif
        default:
        // FIXME: not finished
        fprintf(stderr, "String_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        break;
    }
    token.payload.String = stringPointer;
    token.type = TYPE_String;
    return token;
}
Token String_toString(Token thisToken, ...) {
    return thisToken;
    //    // Guarrantee to return a new string.
    //    char* result = (char*) malloc(sizeof(char) * (3 + strlen(thisToken.payload.String)));
    //    sprintf(result, "\"%s\"", thisToken.payload.String);
    //    return String_new(result);
}
// Array_isCloseTo: Test an array to see whether it is close in value to another.
Token Array_isCloseTo(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    if (thisToken.payload.Array->size != otherToken.payload.Array->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.Array->size; i++) {
        if (!functionTable[(int)Array_get(thisToken, i).type][FUNC_isCloseTo](Array_get(thisToken, i), Array_get(otherToken, i), tolerance).payload.Boolean) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// Array_delete: FIXME: What does this do?
Token Array_delete(Token token, ...) {
    int i;
    Token element, emptyToken;
    // Delete each elements.
    for (i = 0; i < token.payload.Array->size; i++) {
        element = Array_get(token, i);
        functionTable[(int)element.type][FUNC_delete](element);
    }
    free(token.payload.Array->elements);
    free(token.payload.Array);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
// Array_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token Array_convert(Token token, ...) {
    int i;
    Token result;
    Token element;
    va_list argp;
    char targetType;
    va_start(argp, token);
    targetType = va_arg(argp, int);
    result = Array_new(token.payload.Array->size, 0);
    for (i = 0; i < token.payload.Array->size; i++) {
        element = Array_get(token, i);
        if (targetType != element.type) {
            result.payload.Array->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        } else {
            result.payload.Array->elements[i] = element;
        }
    }
    va_end(argp);
    return result;
}
char* toString_Array(Token thisToken) {
    int i;
    int currentSize, allocatedSize;
    char* string;
    Token elementString;
    allocatedSize = 256;
    string = (char*) malloc(allocatedSize);
    string[0] = '{';
        string[1] = '\0';
    // Space for '{', '}', and '\0' characters.
        currentSize = 3;
        for (i = 0; i < thisToken.payload.Array->size; i++) {
            // Calculate the require storage size.
            elementString = functionTable[(int)Array_get(thisToken, i).type][FUNC_toString](Array_get(thisToken, i));
            //functionTable[(int)thisToken.payload.Array->elements[i].type][FUNC_toString](thisToken.payload.Array->elements[i]);
            currentSize += strlen(elementString.payload.String);
            if (i != 0) {
                currentSize += 2;
            }
            // Re-allocate storage.
            if (currentSize > allocatedSize) {
                allocatedSize *= 2;
                string = (char*) realloc(string, allocatedSize);
            }
            // Concat the element strings and separators.
            if (i != 0) {
                strcat(string, ", ");
            }
            strcat(string, elementString.payload.String);
            free(elementString.payload.String);
        }
    strcat(string, "}");
    return string;
}
// Array_toString: Return a string token with a string representation
// of the specified array.
Token Array_toString(Token thisToken, ...) {
    return String_new(toString_Array(thisToken));
    // String_new() calls strdup(), so we free here
    // FIXME: If we free here, then the SequenceArrayToString.xml test crashes?
    //free(string);
}
// DoubleArray_isCloseTo: Test an array to see whether it is close in value to another.
Token DoubleArray_isCloseTo(Token thisToken, ...) {
    int i;
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    otherToken = DoubleArray_convert(otherToken);
    double value1, value2;
    tolerance = va_arg(argp, Token);
    if (thisToken.payload.DoubleArray->size != otherToken.payload.DoubleArray->size) {
        return Boolean_new(false);
    }
    for (i = 0; i < thisToken.payload.DoubleArray->size; i++) {
        value1 = DoubleArray_get(thisToken, i);
        value2 = DoubleArray_get(otherToken, i);
        if (fabs(value1 - value2) > tolerance.payload.Double) {
            return Boolean_new(false);
        }
    }
    va_end(argp);
    return Boolean_new(true);
}
// DoubleArray_delete: FIXME: What does this do?
Token DoubleArray_delete(Token token, ...) {
    Token emptyToken;
    //Token element;
    //int i;
    //char elementType;
    // Delete each elements.
    // for (i = 0; i < token.payload.DoubleArray->size; i++) {
        //     elementType = token.payload.DoubleArray->elementType;
        //     element = DoubleArray_get(token, i);
        //     functionTable[(int) elementType][FUNC_delete](element);
    // }
    free((double *) token.payload.DoubleArray->elements);
    free(token.payload.DoubleArray);
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
// DoubleArray_convert: Convert the first argument array
// into the type specified by the second argument.
// @param token The token to be converted.
// @param targetType The type to convert the elements of the given token to.
Token DoubleArray_convert(Token token, ...) {
    //    int i;
    //    Token result;
    //    Token element;
    //    va_list argp;
    //    char targetType;
    //
    //    va_start(argp, token);
    //    targetType = va_arg(argp, int);
    //
    //    // FIXME: HOW DO WE KNOW WHICH TYPE WE'RE CONVERTING TO?
    //    result = DoubleArray_new(token.payload.DoubleArray->size, 0);
    //
    //    for (i = 0; i < token.payload.DoubleArray->size; i++) {
        //        element = DoubleArray_get(token, i);
        //        if (targetType != token.payload.DoubleArray->elementType) {
            //
            //                DoubleArray_set(result, i, functionTable[(int)targetType][FUNC_convert](element));
            //            // result.payload.DoubleArray->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
        //        } else {
            //                DoubleArray_set(result, i, element);
        //        }
    //    }
    //
    //    va_end(argp);
    //    return result;
    return token;
}
char* toString_DoubleArray(Token thisToken) {
    int i;
    int currentSize, allocatedSize;
    char* string;
    char* elementString;
    allocatedSize = 256;
    string = (char*) malloc(allocatedSize);
    string[0] = '{';
        string[1] = '\0';
    // Space for '{', '}', and '\0' characters.
        currentSize = 3;
        //printf("%d\n", thisToken.payload.DoubleArray->size);
        for (i = 0; i < thisToken.payload.DoubleArray->size; i++) {
            // Calculate the require storage size.
            // double temp = DoubleArray_get(thisToken, i);
            elementString = toString_Double(DoubleArray_get(thisToken, i));
            currentSize += strlen(elementString);
            if (i != 0) {
                currentSize += 2;
            }
            // Re-allocate storage.
            if (currentSize > allocatedSize) {
                allocatedSize *= 2;
                string = (char*) realloc(string, allocatedSize);
            }
            // Concat the element strings and separators.
            if (i != 0) {
                strcat(string, ", ");
            }
            strcat(string, elementString);
        }
    strcat(string, "}");
    return string;
}
// DoubleArray_toString: Return a string token with a string representation
// of the specified array.
Token DoubleArray_toString(Token thisToken, ...) {
    return String_new(toString_DoubleArray(thisToken));
}
Token Int_isCloseTo(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    Token tolerance;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    tolerance = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(fabs(thisToken.payload.Int - otherToken.payload.Int) < tolerance.payload.Double);
}
/* Instead of Int_delete(), we call scalarDelete(). */
Token Int_convert(Token token, ...) {
    switch (token.type) {
        #ifdef TYPE_Double
        case TYPE_Double:
        token.payload.Int = DoubletoInt(token.payload.Double);
        break;
        #endif
        // FIXME: not finished
        default:
        fprintf(stderr, "Int_convert(): Conversion from an unsupported type. (%d)\n", token.type);
        break;
    }
    token.type = TYPE_Int;
    return token;
}
char* toString_Int(int i) {
    char* string = (char*) malloc(sizeof(char) * 12);
    sprintf((char*) string, "%d", i);
    return string;
}
Token Int_toString(Token thisToken, ...) {
    return String_new(toString_Int(thisToken.payload.Int));
}
Token Boolean_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(( thisToken.payload.Boolean && otherToken.payload.Boolean ) ||
    ( !thisToken.payload.Boolean && !otherToken.payload.Boolean ));
}
/* Instead of Boolean_delete(), we call scalarDelete(). */
Token Boolean_convert(Token token, ...) {
    switch (token.type) {
        // FIXME: not finished
        default:
        fprintf(stderr, "Boolean_convert(): Conversion from an unsupported type. (%d)", token.type);
        break;
    }
    token.type = TYPE_Boolean;
    return token;
}
char* toString_Boolean(boolean b) {
    char *results;
    if (b) {
        // AVR does not have strdup
        results = (char*) malloc(sizeof(char) * 5);
        strcpy(results, "true");
    } else {
        results = (char*) malloc(sizeof(char) * 6);
        strcpy(results, "false");
    }
    return results;
}
Token Boolean_toString(Token thisToken, ...) {
    return String_new(toString_Boolean(thisToken.payload.Boolean));
}
/* Generate shared code for GBodyTest */
/* max and min may be used by the Expression actor. */
#ifndef max
#define max(a,b) ((a)>(b)?(a):(b))
#endif
#ifndef min
#define min(a,b) ((a)<(b)?(a):(b))
#endif
int ptolemy_domains_sdf_lib_FIR_length;
int ptolemy_domains_sdf_lib_FIR_newLength;
int ptolemy_domains_sdf_lib_FIR_inC;
int ptolemy_domains_sdf_lib_FIR_phase;
int ptolemy_domains_sdf_lib_FIR_dataIndex;
int ptolemy_domains_sdf_lib_FIR_tapsIndex;
int ptolemy_domains_sdf_lib_FIR_i;
int ptolemy_domains_sdf_lib_FIR_bufferIndex;   // for output offset in a single firing.
int ptolemy_domains_sdf_lib_FIR_inputIndex;        // for input offset.
/* Finished generating shared code for GBodyTest */
/* end shared code */
/* GBodyTest_ArrayToSequence's referenced parameter declarations. */
static boolean GBodyTest_ArrayToSequence_enforceArrayLength_;
static int GBodyTest_ArrayToSequence_arrayLength_;
/* GBodyTest_ArrayToSequence's input variable declarations. */
static Token GBodyTest_ArrayToSequence_input;
/* GBodyTest_Scale's input variable declarations. */
static Token GBodyTest_Scale_input;
/* GBodyTest_ArrayElement's referenced parameter declarations. */
static int GBodyTest_ArrayElement_index_;
/* GBodyTest_ArrayElement's input variable declarations. */
static Token GBodyTest_ArrayElement_input;
/* GBodyTest_Repeat's input variable declarations. */
static Token GBodyTest_Repeat_input;
/* GBodyTest_AddSubtract's input variable declarations. */
static Token GBodyTest_AddSubtract_plus[1][8];
static Token GBodyTest_AddSubtract_minus[1][8];
/* GBodyTest_Expression's input variable declarations. */
static Token GBodyTest_Expression_in[8];
/* GBodyTest_Expression2's input variable declarations. */
static double GBodyTest_Expression2_in[8];
/* GBodyTest_SampleDelay's input variable declarations. */
static Token GBodyTest_SampleDelay_input;
/* GBodyTest_AddSubtract2's input variable declarations. */
static Token GBodyTest_AddSubtract2_plus[2];
/* GBodyTest_MultiplyDivide's input variable declarations. */
static Token GBodyTest_MultiplyDivide_multiply[1][8];
static double GBodyTest_MultiplyDivide_divide[1][8];
/* GBodyTest_AddSubtract3's input variable declarations. */
static Token GBodyTest_AddSubtract3_plus[2];
/* GBodyTest_SampleDelay2's input variable declarations. */
static Token GBodyTest_SampleDelay2_input;
/* GBodyTest_Scale2's input variable declarations. */
static Token GBodyTest_Scale2_input;
/* GBodyTest_FIR's referenced parameter declarations. */
static Token GBodyTest_FIR_taps_;
/* GBodyTest_FIR's input variable declarations. */
static Token GBodyTest_FIR_input[8];
/* GBodyTest_Test's referenced parameter declarations. */
static Token GBodyTest_Test_correctValues_;
static double GBodyTest_Test_tolerance_;
/* GBodyTest_Test's input variable declarations. */
static Token GBodyTest_Test_input[1];
/* GBodyTest_Test's output variable declarations. */
static boolean GBodyTest_Test_output;
/* The preinitialization of the director. */
/* preinitArrayToSequence */
boolean GBodyTest_ArrayToSequence__enforceArrayLength;
int GBodyTest_ArrayToSequence__i;
/* preinitRepeat */
static int GBodyTest_Repeat__i;
static int GBodyTest_Repeat__j;
/* preinitialize AddSubtract */
Token GBodyTest_AddSubtract__result;
/* preinitExpression */
static int GBodyTest_Expression__iterationCount = 1;
/* preinitExpression2 */
static int GBodyTest_Expression2__iterationCount = 1;
/* preinitialize AddSubtract2 */
Token GBodyTest_AddSubtract2__result;
/* preinitialize MultiplyDivide */
Token GBodyTest_MultiplyDivide__result;
/* preinitialize AddSubtract3 */
Token GBodyTest_AddSubtract3__result;
/* preinitFIR */
Token* GBodyTest_FIR___data;
double GBodyTest_FIR___zero;
int GBodyTest_FIR___mostRecent;
int GBodyTest_FIR___phaseLength;
Token GBodyTest_FIR___outToken;
double GBodyTest_FIR___tapItem;
Token GBodyTest_FIR___dataItem;
Token GBodyTest_FIR___taps;
/* preinitTest */
// Initialize to -1 because we ALWAYS increment first.
// This is more convenient for multiport, where we check if \$channel
// number is equal zero (the first channel). If so, then we increment.
int GBodyTest_Test__numberOfTokensSeen = -1;
Token GBodyTest_Test__inputToken;
Token GBodyTest_Test__trainedValues;
static Token GBodyTest_Test__toleranceToken;
/* AddSubtract's offset variables */
static int GBodyTest_AddSubtract_plus_readOffset;
static int GBodyTest_AddSubtract_plus_writeOffset;
static int GBodyTest_AddSubtract_minus_readOffset;
static int GBodyTest_AddSubtract_minus_writeOffset;
/* Expression's offset variables */
static int GBodyTest_Expression_in_readOffset;
static int GBodyTest_Expression_in_writeOffset;
/* Expression2's offset variables */
static int GBodyTest_Expression2_in_readOffset;
static int GBodyTest_Expression2_in_writeOffset;
/* MultiplyDivide's offset variables */
static int GBodyTest_MultiplyDivide_multiply_readOffset;
static int GBodyTest_MultiplyDivide_multiply_writeOffset;
static int GBodyTest_MultiplyDivide_divide_readOffset;
static int GBodyTest_MultiplyDivide_divide_writeOffset;
/* FIR's offset variables */
static int GBodyTest_FIR_input_readOffset;
static int GBodyTest_FIR_input_writeOffset;
/* end preinitialize code */
/* before appending fireFunctionCode */
void GBodyTest_ArrayToSequence(void) {
    if (GBodyTest_ArrayToSequence_enforceArrayLength_ && GBodyTest_ArrayToSequence_input.payload.Array->size != GBodyTest_ArrayToSequence_arrayLength_) {
        printf("\nArrayToSequence fails\n");
        exit(-1);
    }
    for (GBodyTest_ArrayToSequence__i = 0; GBodyTest_ArrayToSequence__i < GBodyTest_ArrayToSequence_input.payload.Array->size; GBodyTest_ArrayToSequence__i++) {
        GBodyTest_AddSubtract_plus[0][(GBodyTest_AddSubtract_plus_writeOffset +  GBodyTest_ArrayToSequence__i)&7] = Array_get(GBodyTest_ArrayToSequence_input, GBodyTest_ArrayToSequence__i);
    }
}
void GBodyTest_Scale(void) {
    GBodyTest_AddSubtract2_plus[1] = multiply_DoubleArray_Double(GBodyTest_Scale_input, 0.01);
}
void GBodyTest_ArrayElement(void) {
    GBodyTest_Repeat_input = Array_get(GBodyTest_ArrayElement_input, GBodyTest_ArrayElement_index_);
}
void GBodyTest_Repeat(void) {
    for (GBodyTest_Repeat__i = 0;
    GBodyTest_Repeat__i < 1;
    GBodyTest_Repeat__i++) {
        for (GBodyTest_Repeat__j = 0;
        GBodyTest_Repeat__j < 6;
        GBodyTest_Repeat__j++) {
            GBodyTest_AddSubtract_minus[0][(GBodyTest_AddSubtract_minus_writeOffset +  GBodyTest_Repeat__j * 1 + GBodyTest_Repeat__i)&7] =
            GBodyTest_Repeat_input;
        }
    }
}
void GBodyTest_AddSubtract(void) {
    GBodyTest_AddSubtract__result = GBodyTest_AddSubtract_plus[0][GBodyTest_AddSubtract_plus_readOffset&7];
    GBodyTest_AddSubtract__result = subtract_IntArray_IntArray(GBodyTest_AddSubtract__result, GBodyTest_AddSubtract_minus[0][GBodyTest_AddSubtract_minus_readOffset&7]);
    GBodyTest_Expression_in[(GBodyTest_Expression_in_writeOffset + 0)&7] = GBodyTest_MultiplyDivide_multiply[0][(GBodyTest_MultiplyDivide_multiply_writeOffset + 0)&7] = GBodyTest_AddSubtract__result;
}
void GBodyTest_Expression(void) {
    GBodyTest_Expression2_in[(GBodyTest_Expression2_in_writeOffset + 0)&7] = sqrt(IntArray_sum((multiply_IntArray_IntArray(GBodyTest_Expression_in[GBodyTest_Expression_in_readOffset&7], GBodyTest_Expression_in[GBodyTest_Expression_in_readOffset&7]))));
}
void GBodyTest_Expression2(void) {
    GBodyTest_MultiplyDivide_divide[0][(GBodyTest_MultiplyDivide_divide_writeOffset + 0)&7] = ((GBodyTest_Expression2_in[GBodyTest_Expression2_in_readOffset&7] == 0) ? 1 : (multiply_Double_Double(multiply_Double_Double(GBodyTest_Expression2_in[GBodyTest_Expression2_in_readOffset&7], GBodyTest_Expression2_in[GBodyTest_Expression2_in_readOffset&7]), GBodyTest_Expression2_in[GBodyTest_Expression2_in_readOffset&7])));
}
void GBodyTest_SampleDelay(void) {

    GBodyTest_AddSubtract2_plus[0] = GBodyTest_Scale2_input = GBodyTest_SampleDelay_input;

}
void GBodyTest_AddSubtract2(void) {
    GBodyTest_AddSubtract2__result = GBodyTest_AddSubtract2_plus[0];
    GBodyTest_AddSubtract2__result = add_DoubleArray_DoubleArray(GBodyTest_AddSubtract2__result, GBodyTest_AddSubtract2_plus[1]);
    GBodyTest_SampleDelay_input = GBodyTest_AddSubtract2__result;
}
void GBodyTest_MultiplyDivide(void) {
    GBodyTest_MultiplyDivide__result = convert_IntArray_DoubleArray(GBodyTest_MultiplyDivide_multiply[0][GBodyTest_MultiplyDivide_multiply_readOffset&7]);
    GBodyTest_MultiplyDivide__result = divide_DoubleArray_Double(GBodyTest_MultiplyDivide__result, GBodyTest_MultiplyDivide_divide[0][GBodyTest_MultiplyDivide_divide_readOffset&7]);
    GBodyTest_FIR_input[(GBodyTest_FIR_input_writeOffset + 0)&7] = GBodyTest_MultiplyDivide__result;
}
void GBodyTest_AddSubtract3(void) {
    GBodyTest_AddSubtract3__result = GBodyTest_AddSubtract3_plus[0];
    GBodyTest_AddSubtract3__result = add_DoubleArray_DoubleArray(GBodyTest_AddSubtract3__result, GBodyTest_AddSubtract3_plus[1]);
    GBodyTest_SampleDelay2_input = GBodyTest_AddSubtract3__result;
}
void GBodyTest_SampleDelay2(void) {

    GBodyTest_AddSubtract3_plus[0] = GBodyTest_Test_input[0] = GBodyTest_SampleDelay2_input;

}
void GBodyTest_Scale2(void) {
    GBodyTest_AddSubtract3_plus[1] = multiply_DoubleArray_Double(GBodyTest_Scale2_input, 0.01);
}
void GBodyTest_FIR(void) {
    ptolemy_domains_sdf_lib_FIR_bufferIndex = 0;
    ptolemy_domains_sdf_lib_FIR_inputIndex = 0;
    // Phase keeps track of which phase of the filter coefficients
    // are used. Starting phase depends on the 0 value.
    ptolemy_domains_sdf_lib_FIR_phase = 6 - 0 - 1;
    // Transfer decimation inputs to _data[]
    for (ptolemy_domains_sdf_lib_FIR_inC = 1; ptolemy_domains_sdf_lib_FIR_inC <= 6; ptolemy_domains_sdf_lib_FIR_inC++) {
        if (--GBodyTest_FIR___mostRecent < 0) {
            GBodyTest_FIR___mostRecent = ptolemy_domains_sdf_lib_FIR_length - 1;
        }
        //_data[_mostRecent] = input.get(0);
        GBodyTest_FIR___data[GBodyTest_FIR___mostRecent] = GBodyTest_FIR_input[(GBodyTest_FIR_input_readOffset +  ptolemy_domains_sdf_lib_FIR_inputIndex++)&7];
    }
    // Interpolate once for each input consumed
    for (ptolemy_domains_sdf_lib_FIR_inC = 1; ptolemy_domains_sdf_lib_FIR_inC <= 6; ptolemy_domains_sdf_lib_FIR_inC++) {
        // Produce however many outputs are required
        // for each input consumed
        while (ptolemy_domains_sdf_lib_FIR_phase < 1) {
            GBodyTest_FIR___outToken = convert_Double_DoubleArray(GBodyTest_FIR___zero);
            // Compute the inner product.
            for (ptolemy_domains_sdf_lib_FIR_i = 0; ptolemy_domains_sdf_lib_FIR_i < GBodyTest_FIR___phaseLength; ptolemy_domains_sdf_lib_FIR_i++) {
                ptolemy_domains_sdf_lib_FIR_tapsIndex = (ptolemy_domains_sdf_lib_FIR_i * 1) + ptolemy_domains_sdf_lib_FIR_phase;
                ptolemy_domains_sdf_lib_FIR_dataIndex = ((GBodyTest_FIR___mostRecent + 6) - ptolemy_domains_sdf_lib_FIR_inC + ptolemy_domains_sdf_lib_FIR_i) % (ptolemy_domains_sdf_lib_FIR_length);
                if (ptolemy_domains_sdf_lib_FIR_tapsIndex < GBodyTest_FIR___taps.payload.DoubleArray->size) {
                    GBodyTest_FIR___tapItem = DoubleArray_get(GBodyTest_FIR___taps, ptolemy_domains_sdf_lib_FIR_tapsIndex);
                    GBodyTest_FIR___dataItem = GBodyTest_FIR___data[ptolemy_domains_sdf_lib_FIR_dataIndex];
                    GBodyTest_FIR___dataItem = multiply_Double_DoubleArray(GBodyTest_FIR___tapItem, GBodyTest_FIR___dataItem);
                    GBodyTest_FIR___outToken = add_DoubleArray_DoubleArray(GBodyTest_FIR___outToken, GBodyTest_FIR___dataItem);
                }
                // else assume tap is zero, so do nothing.
            }
            GBodyTest_Scale_input = GBodyTest_FIR___outToken;
            ptolemy_domains_sdf_lib_FIR_phase += 6;
        }
        ptolemy_domains_sdf_lib_FIR_phase -= 1;
    }
}
void GBodyTest_Const(void) {
    GBodyTest_ArrayToSequence_input = GBodyTest_ArrayElement_input = Array_new(6, 6, IntArray_new(3, 3, 0, 0, 0), IntArray_new(3, 3, 0, 0, 1), IntArray_new(3, 3, 0, 1, 0), IntArray_new(3, 3, 1, 0, 0), IntArray_new(3, 3, 2, 0, 0), IntArray_new(3, 3, 0, 2, 0));
}
void GBodyTest_Test(void) {
    // Array
    GBodyTest_Test__numberOfTokensSeen++;
    GBodyTest_Test__inputToken = GBodyTest_Test_input[0];
    /* If the type of the input is an array, then cast the input to
    * the type of the elements of the elements of correctValues. */
    if (GBodyTest_Test__numberOfTokensSeen < 10) {
        GBodyTest_Test__trainedValues = Array_get(/*CGH77*/Array_get(GBodyTest_Test_correctValues_ , GBodyTest_Test__numberOfTokensSeen), 0);
        if (!functionTable[(int)TYPE_DoubleArray][FUNC_isCloseTo](GBodyTest_Test__trainedValues,
        GBodyTest_Test__inputToken,
        GBodyTest_Test__toleranceToken).payload.Boolean) {
            printf("\nTest GBodyTest_Test__0 fails in iteration %d.\n Value was: %s. Should have been within %10.30g of: %s.\n",
            GBodyTest_Test__numberOfTokensSeen,
            functionTable[(int)GBodyTest_Test__inputToken.type][FUNC_toString](GBodyTest_Test__inputToken).payload.String,
            GBodyTest_Test_tolerance_,
            functionTable[(int)TYPE_DoubleArray][FUNC_toString](GBodyTest_Test__trainedValues).payload.String);
            exit(-1);
        }
    }
}
void GBodyTest(void) {
    /* The firing of the StaticSchedulingDirector */
    GBodyTest_Test();
    GBodyTest_Scale2();
    GBodyTest_AddSubtract3();
    GBodyTest_SampleDelay2();
    GBodyTest_Const();
    GBodyTest_ArrayElement();
    GBodyTest_Repeat();
    GBodyTest_AddSubtract_minus_writeOffset = (GBodyTest_AddSubtract_minus_writeOffset + 6)&7;
    GBodyTest_ArrayToSequence();
    GBodyTest_AddSubtract_plus_writeOffset = (GBodyTest_AddSubtract_plus_writeOffset + 6)&7;
    int GBodyTest_SDF_Director__i;
    for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
        GBodyTest_AddSubtract();
        GBodyTest_AddSubtract_plus_readOffset = (GBodyTest_AddSubtract_plus_readOffset + 1)&7;
        GBodyTest_AddSubtract_minus_readOffset = (GBodyTest_AddSubtract_minus_readOffset + 1)&7;
        GBodyTest_Expression_in_writeOffset = (GBodyTest_Expression_in_writeOffset + 1)&7;
        GBodyTest_MultiplyDivide_multiply_writeOffset = (GBodyTest_MultiplyDivide_multiply_writeOffset + 1)&7;
    }
    for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
        GBodyTest_Expression();
        GBodyTest_Expression_in_readOffset = (GBodyTest_Expression_in_readOffset + 1)&7;
        GBodyTest_Expression2_in_writeOffset = (GBodyTest_Expression2_in_writeOffset + 1)&7;
    }
    for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
        GBodyTest_Expression2();
        GBodyTest_Expression2_in_readOffset = (GBodyTest_Expression2_in_readOffset + 1)&7;
        GBodyTest_MultiplyDivide_divide_writeOffset = (GBodyTest_MultiplyDivide_divide_writeOffset + 1)&7;
    }
    for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
        GBodyTest_MultiplyDivide();
        GBodyTest_MultiplyDivide_multiply_readOffset = (GBodyTest_MultiplyDivide_multiply_readOffset + 1)&7;
        GBodyTest_MultiplyDivide_divide_readOffset = (GBodyTest_MultiplyDivide_divide_readOffset + 1)&7;
        GBodyTest_FIR_input_writeOffset = (GBodyTest_FIR_input_writeOffset + 1)&7;
    }
    GBodyTest_FIR();
    GBodyTest_FIR_input_readOffset = (GBodyTest_FIR_input_readOffset + 6)&7;
    GBodyTest_Scale();
    GBodyTest_AddSubtract2();
    GBodyTest_SampleDelay();
}
/* after appending fireFunctionCode */
void initialize(void) {
    /* ArrayToSequence's parameter initialization */
    GBodyTest_ArrayToSequence_enforceArrayLength_ = true;
    GBodyTest_ArrayToSequence_arrayLength_ = 6;
    /* ArrayElement's parameter initialization */
    GBodyTest_ArrayElement_index_ = 0;
    /* FIR's parameter initialization */
    GBodyTest_FIR_taps_ = DoubleArray_repeat(6, 1.0);
    /* Test's parameter initialization */
    GBodyTest_Test_correctValues_ = Array_new(10, 10, Array_new(1, 1, DoubleArray_new(3, 3, 0.0, 0.0, 0.0)), Array_new(1, 1, DoubleArray_new(3, 3, 0.0, 0.0, 0.0)), Array_new(1, 1, DoubleArray_new(3, 3, 1.25E-4, 1.25E-4, 1.0E-4)), Array_new(1, 1, DoubleArray_new(3, 3, 3.75E-4, 3.75E-4, 3.0E-4)), Array_new(1, 1, DoubleArray_new(3, 3, 7.5E-4, 7.5E-4, 6.0E-4)), Array_new(1, 1, DoubleArray_new(3, 3, 0.00125, 0.00125, 1.0E-3)), Array_new(1, 1, DoubleArray_new(3, 3, 0.001875, 0.001875, 0.0015)), Array_new(1, 1, DoubleArray_new(3, 3, 0.002625, 0.002625, 0.0021)), Array_new(1, 1, DoubleArray_new(3, 3, 0.0035, 0.0035, 0.0028)), Array_new(1, 1, DoubleArray_new(3, 3, 0.0045, 0.0045, 0.0036)));
    GBodyTest_Test_tolerance_ = 1.0E-9;
    /* AddSubtract's input offset initialization */
    GBodyTest_AddSubtract_plus_readOffset = 0;
    GBodyTest_AddSubtract_plus_writeOffset = 0;
    GBodyTest_AddSubtract_minus_readOffset = 0;
    GBodyTest_AddSubtract_minus_writeOffset = 0;
    /* Expression's input offset initialization */
    GBodyTest_Expression_in_readOffset = 0;
    GBodyTest_Expression_in_writeOffset = 0;
    /* Expression2's input offset initialization */
    GBodyTest_Expression2_in_readOffset = 0;
    GBodyTest_Expression2_in_writeOffset = 0;
    /* MultiplyDivide's input offset initialization */
    GBodyTest_MultiplyDivide_multiply_readOffset = 0;
    GBodyTest_MultiplyDivide_multiply_writeOffset = 0;
    GBodyTest_MultiplyDivide_divide_readOffset = 0;
    GBodyTest_MultiplyDivide_divide_writeOffset = 0;
    /* FIR's input offset initialization */
    GBodyTest_FIR_input_readOffset = 0;
    GBodyTest_FIR_input_writeOffset = 0;
    /* The initialization of the director. */
    /* initialize SampleDelay */
    GBodyTest_AddSubtract2_plus[0] = GBodyTest_Scale2_input = convert_IntArray_DoubleArray(IntArray_new(3, 3, 0, 0, 0));

    /* initialize SampleDelay2 */
    GBodyTest_AddSubtract3_plus[0] = GBodyTest_Test_input[0] = convert_IntArray_DoubleArray(IntArray_new(3, 3, 0, 0, 0));

    GBodyTest_FIR___taps = GBodyTest_FIR_taps_;
    /* initFIR */
    GBodyTest_FIR___zero = zero_Double(DoubleArray_get(GBodyTest_FIR___taps, 0));
    GBodyTest_FIR___phaseLength = GBodyTest_FIR___taps.payload.DoubleArray->size / 1;
    if ((GBodyTest_FIR___taps.payload.DoubleArray->size % 1) != 0) {
        GBodyTest_FIR___phaseLength++;
    }
    // Create new data array and initialize index into it.
    // Avoid losing the data if possible.
    // NOTE: If the filter length increases, then it is impossible
    // to correctly initialize the delay line to contain previously
    // seen data, because that data has not been saved.
    ptolemy_domains_sdf_lib_FIR_length = GBodyTest_FIR___phaseLength + 6;
    GBodyTest_FIR___data = (Token*) realloc(GBodyTest_FIR___data, ptolemy_domains_sdf_lib_FIR_length * sizeof(Token));
    for (ptolemy_domains_sdf_lib_FIR_i = 0; ptolemy_domains_sdf_lib_FIR_i < ptolemy_domains_sdf_lib_FIR_length; ptolemy_domains_sdf_lib_FIR_i++) {
        GBodyTest_FIR___data[ptolemy_domains_sdf_lib_FIR_i] = convert_Double_DoubleArray(GBodyTest_FIR___zero);
    }
    GBodyTest_FIR___mostRecent = GBodyTest_FIR___phaseLength;
    GBodyTest_Test__toleranceToken = Double_new(GBodyTest_Test_tolerance_);
}
void wrapup(void) {
    /* The wrapup of the director. */
    /* wrapupFIR */
    free(GBodyTest_FIR___data);
    /* wrapupTest */
    if ((GBodyTest_Test__numberOfTokensSeen + 1) < 10) {
        printf("\nTest produced only %d tokens, yet the correctValues parameter was expecting %d tokens.\n", GBodyTest_Test__numberOfTokensSeen, 10);
        exit(-2);
    }
}
int main(int argc, char *argv[]) {
    initialize();
    int iteration;
    for (iteration = 0; iteration < 10; iteration ++) {
        /* The firing of the StaticSchedulingDirector */
        GBodyTest_Test();
        GBodyTest_Scale2();
        GBodyTest_AddSubtract3();
        GBodyTest_SampleDelay2();
        GBodyTest_Const();
        GBodyTest_ArrayElement();
        GBodyTest_Repeat();
        GBodyTest_AddSubtract_minus_writeOffset = (GBodyTest_AddSubtract_minus_writeOffset + 6)&7;
        GBodyTest_ArrayToSequence();
        GBodyTest_AddSubtract_plus_writeOffset = (GBodyTest_AddSubtract_plus_writeOffset + 6)&7;
        int GBodyTest_SDF_Director__i;
        for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
            GBodyTest_AddSubtract();
            GBodyTest_AddSubtract_plus_readOffset = (GBodyTest_AddSubtract_plus_readOffset + 1)&7;
            GBodyTest_AddSubtract_minus_readOffset = (GBodyTest_AddSubtract_minus_readOffset + 1)&7;
            GBodyTest_Expression_in_writeOffset = (GBodyTest_Expression_in_writeOffset + 1)&7;
            GBodyTest_MultiplyDivide_multiply_writeOffset = (GBodyTest_MultiplyDivide_multiply_writeOffset + 1)&7;
        }
        for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
            GBodyTest_Expression();
            GBodyTest_Expression_in_readOffset = (GBodyTest_Expression_in_readOffset + 1)&7;
            GBodyTest_Expression2_in_writeOffset = (GBodyTest_Expression2_in_writeOffset + 1)&7;
        }
        for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
            GBodyTest_Expression2();
            GBodyTest_Expression2_in_readOffset = (GBodyTest_Expression2_in_readOffset + 1)&7;
            GBodyTest_MultiplyDivide_divide_writeOffset = (GBodyTest_MultiplyDivide_divide_writeOffset + 1)&7;
        }
        for (GBodyTest_SDF_Director__i = 0; GBodyTest_SDF_Director__i < 6 ; GBodyTest_SDF_Director__i++) {
            GBodyTest_MultiplyDivide();
            GBodyTest_MultiplyDivide_multiply_readOffset = (GBodyTest_MultiplyDivide_multiply_readOffset + 1)&7;
            GBodyTest_MultiplyDivide_divide_readOffset = (GBodyTest_MultiplyDivide_divide_readOffset + 1)&7;
            GBodyTest_FIR_input_writeOffset = (GBodyTest_FIR_input_writeOffset + 1)&7;
        }
        GBodyTest_FIR();
        GBodyTest_FIR_input_readOffset = (GBodyTest_FIR_input_readOffset + 6)&7;
        GBodyTest_Scale();
        GBodyTest_AddSubtract2();
        GBodyTest_SampleDelay();
        /* The postfire of the director. */
        /* postfireExpression */
        GBodyTest_Expression__iterationCount++;
        /* postfireExpression2 */
        GBodyTest_Expression2__iterationCount++;
        /* postfireTest */
        // FIXME: should we update this here?
        //GBodyTest_Test__numberOfTokensSeen++;
    }
    wrapup();
    exit(0);
}
